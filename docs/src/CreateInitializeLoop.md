# Control flow

```@meta
CurrentModule = PALEOboxes
```
## Model Creation

A [YAML](https://en.wikipedia.org/wiki/YAML) format configuration file defines both the model structure (spatial domains containing biogeochemical variables and reactions that operate on them) and model parameter values. Reactions (subtypes of [`AbstractReaction`](@ref)) are registered in [`reaction_factories`](@ref) Dict and identified by name in the configuration file.

To create the model, the numerical solver or host should call [`create_model_from_config`](@ref) which reads the configuration file, and then:
- creates model [`Domain`](@ref)s and Reactions (subtypes of [`AbstractReaction`](@ref)), applying any [`Parameter`](@ref)s settings from the `parameters:` sections in the config file.
- calls [`set_model_geometry`](@ref) allowing Reactions to create and attach Grids ([`AbstractMesh`](@ref) subtypes) defining [`Domain`](@ref) sizes.
- calls [`register_methods!`](@ref) on each Reaction, allowing Reactions to define local [`VariableReaction`](@ref)s and register [`ReactionMethod`](@ref)s. [`ReactionMethod`](@ref)s can be added to one of three groups, by calling [`add_method_setup!`](@ref) (called during model setup), [`add_method_initialize!`](@ref) (called at start of main loop) [`add_method_do!`](@ref) (called during main loop).
 - links [`VariableReaction`](@ref)s to [`VariableDomain`](@ref)s, applying any renaming from the `variable_links:` sections in the config file.
 - calls [`register_dynamic_methods!`](@ref) on each Reaction, allowing Reactions to create [`VariableReaction`](@ref)s and register [`ReactionMethod`](@ref)s that depend on [`VariableDomain`](@ref)s created by other Reactions.
 - relinks [`VariableReaction`](@ref)s to [`VariableDomain`](@ref)s to include these additional [`VariableReaction`](@ref)s 
 - sorts each group of [`ReactionMethod`](@ref)s into dispatch order based on dependencies between Variables, storing the sorted lists in the [`Model`](@ref) struct.


## Model initialisation

To initialise the model, the numerical solver or host should then:
- call [`create_modeldata`](@ref) to create a [`ModelData`](@ref) struct that will store data Arrays for model Variables. A default Vector of [`CellRange`](@ref)s covering the whole model, generated by [`create_default_cellrange`](@ref), is also stored in the `cellranges_all` field of the [`ModelData`](@ref) struct.
- call [`allocate_variables!`](@ref) to allocate memory for model Variables, storing these Array references in the [`ModelData`](@ref) struct.
- optionally call [`set_default_solver_view!`](@ref) to create a default [`SolverView`](@ref) struct for the whole model, and store a reference in the `solverview_all` field of the [`ModelData`](@ref) struct.
- call [`check_ready`](@ref) to check that all Variables are allocated.
- call [`initialize_reactiondata!`](@ref) to:
  - store sorted lists of [`ReactionMethod`](@ref)s and corresponding Variable array accessors in the [`ModelData`](@ref) struct. A [`ReactionMethod`](@ref) may include a prepare function to include additional buffers etc.
  - call [`create_dispatch_methodlists`](@ref) to compile default model-wide lists of `initialize` and `do` methods + corresponding Variable array accessors and [`CellRange`](@ref)s. This is stored as the in the `dispatchlists_all` of the [`ModelData`](@ref) struct.
- call [`check_configuration`](@ref) to call any optional [`check_configuration`](@ref) Reaction methods to validate the model configuration.

## State Variable initialization
To initialise state Variables and perform any Reaction-specific initialisation, the numerical solver or host should:
- optionally (if normalisation values are required by a numerical solver), 
  - call [`dispatch_setup`](@ref) with `attribute_value = :norm_value`, which calls Reaction setup methods (registered by [`add_method_setup!`](@ref)). These methods should set state Variables according to the `:norm_value` Variable attribute (which can be set in the `variable_attributes:` section of the config file).
  - call [`copy_norm!`](@ref) to copy the Variable normalisation values from the arrays in [`ModelData`](@ref) to a [`SolverView`](@ref) struct.
- call [`dispatch_setup`](@ref) with `attribute_value = :initial_value` to set state Variables according to the `:initial_value` Variable attribute (which can be set in the `variable_attributes:` section of the config file).

## Main loop
To calculate the model derivative, the numerical solver or host should:
- call [`do_deriv`](@ref) to call lists of `initialize` and `do` methods created by [`create_dispatch_methodlists`](@ref)

## Additional notes

### SolverView vs embedding in a host model.
A [`SolverView`](@ref) uses a collection of [`VariableAggregator`](@ref)s to assemble model state Variables and associated time derivatives into contiguous Vectors, for the convenience of standard numerical ODE / DAE solvers. It is not required eg if the PALEO model is embedded in a host model that implements its own time stepping.

### Operator splitting and Domain tiling: Reaction and Domain subsets
The default initialisation described above calculates the model derivative for all model Reactions for all Domains, using
the `cellranges_all`, `solverview_all` and `dispatchlists_all` fields of the [`ModelData`](@ref) struct.  A custom Vector of [`CellRange`](@ref)s can be used to select a subset of [`ReactionMethod`](@ref)s by [`Domain`](@ref) and `operatorID`, eg to implement operator splitting. Tiles within [`Domain`](@ref) eg to implement Domain decomposition for a multithreaded model can be defined by specifying [`CellRange`](@ref)s with a subset of cell indices within [`Domain`](@ref)s.

The custom Vector of [`CellRange`](@ref)s should then be supplied to [`create_dispatch_methodlists`](@ref) to create lists of methods + corresponding [`CellRange`](@ref)s which can then be supplied to [`do_deriv`](@ref) for the model main loop.

If required, a custom Vector of [`CellRange`](@ref)s can be supplied to [`create_solver_view`](@ref) to create a corresponding [`SolverView`](@ref) containing[`VariableAggregator`](@ref)s for subsets of Variables and tiles within [`Domain`](@ref)s.

### Multithreaded models
To use with a multithreaded solver eg for a spatially tiled model:
- Set `threadsafe=true` when calling [`create_modeldata`](@ref). The subsequent call to [`allocate_variables!`](@ref) will then allocate Julia `Threads.Atomic` variables for PALEO Variables with attribute `atomic: = true` (usually scalar accumulator variables for totals etc).
- Supply a `method_barrier` implementing a thread barrier function to [`initialize_reactiondata!`](@ref). Reactions are sorted into groups, where each group has no dependencies and later groups depend on earlier ones. The `method_barrier` will be inserted between these groups of independent Reactions.

### Automatic differentiation
- Set `eltype` when calling [`create_modeldata`](@ref) to the appropriate dual number type for a (forward) automatic differentation implementation. All model arrays are held in the created [`ModelData`](@ref) struct and multiple [`ModelData`](@ref) instances can be created, allowing a combination of eg AD Jacobian and standard derivative calculations with different array types.

