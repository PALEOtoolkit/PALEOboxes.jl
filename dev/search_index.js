var documenterSearchIndex = {"docs":
[{"location":"CreateInitializeLoop/#Control-flow","page":"Control flow","title":"Control flow","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"CreateInitializeLoop/#Model-Creation","page":"Control flow","title":"Model Creation","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"A YAML format configuration file defines both the model structure (spatial domains containing biogeochemical variables and reactions that operate on them) and model parameter values. Reactions (subtypes of AbstractReaction) are identified by Type name (without module prefix) in the configuration file.","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"To create the model, the numerical solver or host should call create_model_from_config which reads the configuration file, and then:","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"creates model Domains and Reactions (subtypes of AbstractReaction), applying any Parameters settings from the parameters: sections in the config file.\ncalls set_model_geometry allowing Reactions to create and attach Grids (AbstractMesh subtypes) defining Domain sizes.\ncalls register_methods! on each Reaction, allowing Reactions to define local VariableReactions and register ReactionMethods. ReactionMethods can be added to one of three groups, by calling add_method_setup! (called during model setup), add_method_initialize! (called at start of main loop) add_method_do! (called during main loop).\nlinks VariableReactions to VariableDomains, applying any renaming from the variable_links: sections in the config file.\ncalls register_dynamic_methods! on each Reaction, allowing Reactions to create VariableReactions and register ReactionMethods that depend on VariableDomains created by other Reactions.\nrelinks VariableReactions to VariableDomains to include these additional VariableReactions \nsorts each group of ReactionMethods into dispatch order based on dependencies between Variables, storing the sorted lists in the Model struct.","category":"page"},{"location":"CreateInitializeLoop/#Model-initialisation","page":"Control flow","title":"Model initialisation","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"To initialise the model, the numerical solver or host should then:","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"call create_modeldata to create a ModelData struct that will store data Arrays for model Variables. A default Vector of CellRanges covering the whole model, generated by create_default_cellrange, is also stored in the cellranges_all field of the ModelData struct.\ncall allocate_variables! to allocate memory for model Variables, storing these Array references in the ModelData struct.\ncall check_ready to check that all Variables are allocated.\ncall initialize_reactiondata! to:\nstore sorted lists of ReactionMethods and corresponding Variable array accessors in the ModelData struct. A ReactionMethod may include a prepare function to include additional buffers etc.\ncall create_dispatch_methodlists to compile default model-wide lists of initialize and do methods + corresponding Variable array accessors and CellRanges. This is stored as the in the dispatchlists_all of the ModelData struct.\ncall check_configuration to call any optional check_configuration Reaction methods to validate the model configuration.\ncall dispatch_setup with attribute_name = :setup, which calls Reaction setup methods (registered by add_method_setup!) to initialise any internal Reaction state and any non-state Variables (eg grid variables).","category":"page"},{"location":"CreateInitializeLoop/#State-Variable-initialization","page":"Control flow","title":"State Variable initialization","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"To initialise state Variables and perform any Reaction-specific initialisation, the numerical solver or host should:","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"call dispatch_setup with attribute_name = :norm_value. These Reaction setup methods should set state Variables according to the :norm_value Variable attribute (which can be set in the variable_attributes: section of the config file). Reactions may also use these values internally.\noptionally (if normalisation values are required by a numerical solver), copy the Variable normalisation values from the arrays in ModelData to the solver.\noptionally call dispatch_setup with attribute_name = :initial_value to set state Variables according to the :initial_value Variable attribute (which can be set in the variable_attributes: section of the config file).","category":"page"},{"location":"CreateInitializeLoop/#Main-loop","page":"Control flow","title":"Main loop","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"To calculate the model derivative, the numerical solver or host should:","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"call do_deriv to call lists of initialize and do methods created by create_dispatch_methodlists","category":"page"},{"location":"CreateInitializeLoop/#Additional-notes","page":"Control flow","title":"Additional notes","text":"","category":"section"},{"location":"CreateInitializeLoop/#Operator-splitting-and-Domain-tiling:-Reaction-and-Domain-subsets","page":"Control flow","title":"Operator splitting and Domain tiling: Reaction and Domain subsets","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"The default initialisation described above calculates the model derivative for all model Reactions for all Domains, using the cellranges_all, and dispatchlists_all fields of the ModelData struct.  A custom Vector of CellRanges can be used to select a subset of ReactionMethods by Domain and operatorID, eg to implement operator splitting. Tiles within Domain eg to implement Domain decomposition for a multithreaded model can be defined by specifying CellRanges with a subset of cell indices within Domains.","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"The custom Vector of CellRanges should then be supplied to ","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"create_dispatch_methodlists to create lists of methods + corresponding CellRanges which can then be supplied to do_deriv for the model main loop.\nOptionally to VariableAggregators to create subsets of Variables and tiles within Domains for a numerical solver.","category":"page"},{"location":"CreateInitializeLoop/#Multithreaded-models","page":"Control flow","title":"Multithreaded models","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"To use with a multithreaded solver eg for a spatially tiled model:","category":"page"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"Set threadsafe=true when calling create_modeldata. The subsequent call to allocate_variables! will then allocate Julia Threads.Atomic variables for PALEO Variables with attribute atomic: = true (usually scalar accumulator variables for totals etc).\nSupply a method_barrier implementing a thread barrier function to initialize_reactiondata!. Reactions are sorted into groups, where each group has no dependencies and later groups depend on earlier ones. The method_barrier will be inserted between these groups of independent Reactions.","category":"page"},{"location":"CreateInitializeLoop/#Automatic-differentiation","page":"Control flow","title":"Automatic differentiation","text":"","category":"section"},{"location":"CreateInitializeLoop/","page":"Control flow","title":"Control flow","text":"Set eltype when calling create_modeldata to the appropriate dual number type for a (forward) automatic differentation implementation. All model arrays are held in the created ModelData struct and multiple ModelData instances can be created, allowing a combination of eg AD Jacobian and standard derivative calculations with different array types.","category":"page"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"indexpage/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexpage/","page":"Index","title":"Index","text":"","category":"page"},{"location":"DesignOverview/#PALEOboxes-coupler-design","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"A PALEO Model contains Domains, each of which contain Variables defining Fields containing Data arrays, and Reactions with ReactionMethods that operate on the Variables to calculate model time evolution.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"The PALEOboxes Julia package (abbreviated to PB in the PALEO code) implements a coupler that provides a unified mechanism for","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"‘low-level’ coupling (e.g. linking individual redox Reactions within a Domain), on which is built\n‘module-level’ coupling (linking e.g. atmosphere and ocean components) based on standardising names for communicating fluxes, and which enables\nseparation of biogeochemical reaction and transport. ","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"A YAML format configuration file then defines both the model structure (spatial domains containing biogeochemical variables and reactions that operate on them) and model parameter values.","category":"page"},{"location":"DesignOverview/#Composing-Reactions-and-Variables-within-a-[Domain](@ref)","page":"PALEOboxes coupler design","title":"Composing Reactions and Variables within a Domain","text":"","category":"section"},{"location":"DesignOverview/#Figure-1","page":"PALEOboxes coupler design","title":"Figure 1","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"(Image: )","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"The PALEOboxes object model illustrated by a fragment of a marine biogeochemical model representing two phytoplankton populations competing for the same nutrient. The Ocean Domain contains two Reactions phytA and phytB, and three state Variables P, phytA and phytB with paired time derivatives P_sms, phytA_sms and phytB_sms. The Reactions are both instances of the same class PaleoReactionSimplePhyt, with a Parameter k_P, and a single method. The ReactionMethod defines interactions with a nutrient P via a Variable Dependency P and a Variable Contributor P_sms, and a population represented by Variable Dependency phyt and Contributor phyt_sms. P and P_sms from each PaleoReactionSimplePhyt instance are linked at run time to the same Domain Variables P and P_sms, using the default names from the PaleoReactionSimplePhyt code.  phyt and phyt_sms are renamed in the configuration file to two different pairs of Domain Variables phytA, phytA_sms and phytB, phytB_sms, hence representing two distinct phytoplankton populations.","category":"page"},{"location":"DesignOverview/#Reactions-and-ReactionMethods","page":"PALEOboxes coupler design","title":"Reactions and ReactionMethods","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Reactions contain Parameters and are implemented as subtypes of AbstractReaction along with associated methods. ReactionMethods and VariableReactions are created by Reactions during model initialization. All PALEO model time evolution (including external prescribed forcing, biogeochemistry, transport within eg an ocean Domain) is then implemented by the ReactionMethods as they are called during the model main loop.","category":"page"},{"location":"DesignOverview/#Biogeochemical-Variables","page":"PALEOboxes coupler design","title":"Biogeochemical Variables","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Variables defined as VariableReactions are then linked within (or across) Domains, creating corresponding VariableDomains.  Linking of Variables is based on names (as text strings).  Default names are encoded in the Reaction implementations (with standard names for e.g. chemical species such as O2, DIC marine tracers), and can be overridden in the configuration file.  This is analogous to the use of ‘dummy variables’ in a Fortran or Python function  call, and allows (i) a combination of default names for commonly-used biogeochemical variables (‘P’, ‘SO4’ etc), with (ii) renamed variables to allow multiple Reaction instances (e.g. two phytoplankton populations with state variable names and parameter choices for the same Reaction implementation),  or (iii) enable rerouting of fluxes and dependencies that are specific to the model configuration, or (iv) sort out name conflicts where no default names have been established.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Variables are classified into two pairings: Properties with Dependencies (shown shaded green in Figure 1, linked at run time to Domain VariableDomPropDeps),  or flux Targets and Contributors (shaded pink in Figure 1, linked at run-time to Domain VariableDomContribTargets). This classification retains flexibility while providing sufficient information to allow automatic detection of errors in model specification (for example, a Dependency with no Property, or a flux Contributor with no Target), and automatic scheduling of Reactions within the model main loop (as a Reaction that defines a Property must be executed before a Reaction that Depends on this property).","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Variables can specify metadata as an extensible list of attributes which can then be queried (using get_attribute) and filtered on (using get_variables) during model configuration and initialisation. This enables the labelling of groups of variables (e.g. the :advect and :vertical_motion attributes are used by a Reaction implementing ocean transport to identify those state variables representing solutes that should be transported; the :vfunction attribute is used by numerical solvers to identify state variables and their time derivatives).","category":"page"},{"location":"DesignOverview/#Spatially-resolved-Domains-and-Grids","page":"PALEOboxes coupler design","title":"Spatially-resolved Domains and Grids","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Domains may contain a Grid (a subtype of AbstractMesh) to define a spatially-resolved Domain containing multiple cells.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Three-dimensional Domains (eg ocean) are associated with two-dimensional boundary Domains (eg oceansurface, oceanfloor), and also provide Subdomains (subtypes of AbstractSubdomain, eg ocean.oceansurface, ocean.oceanfloor) that specify the subset of 3D ocean cells adjacent to the 2D boundaries.","category":"page"},{"location":"DesignOverview/#Fields-and-Data","page":"PALEOboxes coupler design","title":"Fields and Data","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Variables contain Fields which represent data (a subtype of AbstractData defined by the :field_data ttribute) in a function space (a subtype of AbstractSpace defined by the :space attribute).","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"The AbstractSpace subtype (see Spaces) can define a per-Domain (ScalarSpace) or per-cell (CellSpace) quantity, where the number of cells is defined by the Domain grid.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"The AbstractData subtype (see Data types) defines the information that is stored per Domain or per grid cell. ScalarData defines one value, ArrayScalarData an array of scalar values eg for intensity on a wavelength grid, and AbstractIsotopeScalar a multiple-component isotope system (see Isotopes).","category":"page"},{"location":"DesignOverview/#Coupling-Spatial-Domains","page":"PALEOboxes coupler design","title":"Coupling Spatial Domains","text":"","category":"section"},{"location":"DesignOverview/#Figure-2","page":"PALEOboxes coupler design","title":"Figure 2","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"(Image: )","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Defining and coupling spatial Domains.  The four Domains atm, oceansurface, ocean and fluxAtmOceansurface are defined in the model configuration file. The first three of these contain arbitrary biogeochemical Reactions and Variables. Domain fluxAtmOceansurface contains only a FluxTarget Reaction and a set of Target Variables fluxO2. Exchange fluxes are accumulated into these flux Variables (in this case, produced by air-sea exchange reactions in the oceansurface Domain), and then redistributed to atm and ocean by the FluxTransfer Reactions taking account of mapping between Domain dimensions.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Coupling between Earth system components is provided by Fluxes, implemented by Fluxes.ReactionFluxTargets (Figure 2) that provide a set of flux Target Variables in nominated flux coupler Domains, and Fluxes.ReactionFluxTransfer that then transfer fluxes (with appropriate mapping) to a different Domain.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"Variable text names may be referred to from other Domains by prefixing with Domain and Subdomain names (eg ocean.P_conc links to the 3D ocean interior Variable P_conc, ocean.oceansurface.O2_conc links to the ocean oxygen concentration for the 2D subset of ocean cells adjacent to the oceansurface boundary).","category":"page"},{"location":"DesignOverview/#Separating-time-integration,-reaction,-and-transport","page":"PALEOboxes coupler design","title":"Separating time integration, reaction, and transport","text":"","category":"section"},{"location":"DesignOverview/#Figure-3","page":"PALEOboxes coupler design","title":"Figure 3","text":"","category":"section"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"(Image: ) Examples of model configurations with different reaction/transport partitioning: a) a configuration with offline transport and forcing provided by Reactions within the PALEO framework. The only external dependencies are state variables and derivatives, with time integration provided by a standard ODE solver such as CVODE and the overall model workflow (initialisation, solution, output) managed by the PALEOmodel package. b) an ocean-only model embedded in a GCM host which provides transport and physical properties such as temperature and sequences the model workflow.","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"The :vfunction Variable attribute is used to identify pairs of state variables (labelled with :vfunction = VF_StateExplicit) and their corresponding time derivatives (labelled with :vfunction = VF_Deriv). Algebraic constraints are defined by Variables labelled with :vfunction = VF_Constraint, with a corresponding number of state variables labelled with :vfunction = VF_State. Implicit variables are defined by pairs of variables and time derivatives labelled with :vfunction = VF_Total and  :vfunction = VF_Deriv, with a corresponding number of state variables labelled with :vfunction = VF_State. ","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"To access variables, a numerical ODE or DAE solver can use VariableAggregator to implement a high-level interface to aggregated lists. A host dynamical model can alternatively use get_variables during model configuration and initialisation to link to individual host data arrays.  ","category":"page"},{"location":"DesignOverview/","page":"PALEOboxes coupler design","title":"PALEOboxes coupler design","text":"The abstractions described above enable a natural separation of biogeochemical reaction and transport, which can then either be provided by a host dynamical model e.g. implemented in C or Fortran, or as offline transport implemented by PALEO “reactions” within the framework (Figure 3). This enables both rapid, interactive development and experimentation in a PC/workstation environment using offline transport, and deployment of the same model code as a component embedded in a larger GCM model.","category":"page"},{"location":"DomainsVariablesFields/#Domains,-Variables,-Fields,-and-Data-arrays.","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"A Model contains Domains, each of which contain Variables defining Fields which contain Data arrays, and Reactions with ReactionMethods that operate on the Fields to calculate model time evolution.","category":"page"},{"location":"DomainsVariablesFields/#Model","page":"Domains, Variables, Fields, and Data arrays.","title":"Model","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Model","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Model","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Model","text":"Model\n\nA biogeochemical model consisting of Domains, created from a YAML configuration file using create_model_from_config.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#Domains","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Domain","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Domain","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Domain","text":"Domain\n\nA model region containing Variables and Reactions that act on them.\n\nDomain spatial size is defined by grid, which may be nothing to define a scalar Domain, or an AbstractMesh to define a spatially-resolved Domain with multiple cells.\n\nNamed data_dims may be set by set_data_dimension! to allow Variables with additional non-spatial dimensions, eg to represent quantities on a wavelength grid.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#Grids","page":"Domains, Variables, Fields, and Data arrays.","title":"Grids","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"AbstractMesh\n\ninternal_size\ncartesian_size","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.AbstractMesh","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.AbstractMesh","text":"AbstractMesh\n\nDefines additional geometric and topological information for PB.Domain\n\nConcrete subtypes should implement methods:\n\nPB.internal_size, optionally PB.cartesian_size\n\nPB.Grids.set_subdomain!, PB.Grids.get_subdomain\n\nPB.Grids.create_default_cellrange, PB.Grids.get_region\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.internal_size","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.internal_size","text":"internal_size(::Type{<:AbstractSpace}, mesh::AbstractMesh; [subdomain=\"\"] [space=:cell]) -> NTuple{ndims, Int}\n\nArray size to use for model Variables.\n\nAll AbstractMesh concrete subtypes (UnstructuredVectorGrid, CartesianLinearGrid, ...) should implement this method.\n\nOptional Keyword Arguments\n\nsubdomain::String=\"\": a named subdomain  \n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.cartesian_size","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.cartesian_size","text":"cartesian_size(mesh::AbstractMesh) -> NTuple{ndims, Int}\n\nOptional (only regular Cartesian grids should implement this method): Array size of Cartesian Domain.\n\nNB: this may be different from internal_size if the mesh implements a mapping  eg to a Vector for internal model Variables.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes.Grids","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"set_subdomain!\nget_subdomain\n\nUnstructuredVectorGrid\nUnstructuredColumnGrid\nCartesianLinearGrid\nCartesianArrayGrid","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.set_subdomain!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.set_subdomain!","text":"set_subdomain!(grid::PB.AbstractMesh, subdomainname::AbstractString, subdom::PB.AbstractSubdomain, allowcreate::Bool=false)\n\nSet Subdomain\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.get_subdomain","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.get_subdomain","text":"get_subdomain(grid::PB.AbstractMesh, subdomainname::AbstractString) -> PB.AbstractSubdomain\n\nGet Subdomain\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.UnstructuredVectorGrid","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.UnstructuredVectorGrid","text":"UnstructuredVectorGrid <: PB.AbstractMesh\n\nMinimal Grid for a Vector Domain, defines only some named cells for plotting\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.UnstructuredColumnGrid","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.UnstructuredColumnGrid","text":"UnstructuredColumnGrid <: PB.AbstractMesh\n\nMinimal Grid for a Vector Domain composed of columns (not necessarily forming a 2-D array).\n\nFields\n\nncells::Int total number of cells in this Domain\nIcolumns::Vector{Vector{Int}}: Icolumns[n] should be the indices of column n, in order from surface to floor, where n is also the index of \n\nany associated boundary surface.\n\nz_coords::Vector{FixedCoord}: z coordinates of cell mid point, lower surface, upper surface\ncolumnnames::Vector{Symbol}: optional column names\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.CartesianLinearGrid","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.CartesianLinearGrid","text":"CartesianLinearGrid <: PB.AbstractMesh\n\nnD grid with netcdf CF1.0 coordinates, using Vectors for PALEO internal representation of Variables, with a mapping linear indices <–> some subset of grid indices.\n\nThe linear indices mapping should be set with set_linear_index. Conversion of Field values between the PALEO internal representation (a Vector with a linear index) and a Cartesian Array with multiple dimensions (for import and export of model output) is then implemented by cartesian_to_internal and internal_to_cartesian.\n\nFields\n\nncells::Int64: number of cells in Domain = length(linear_index) (may be subset of total points in prod(dims))\ndimnames::Vector{String}: names of dimensions (ordered list)\ndims::Vector{Int}: sizes of dimensions (ordered list)\ncoords::Vector{Vector{Float64}}: attached cell-centre coordinates for each dimension (ordered list)\ncoords_edges::Vector{Vector{Float64}}: attached cell-edge coordinates for each dimension (ordered list)\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.CartesianArrayGrid","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.CartesianArrayGrid","text":"CartesianArrayGrid <: PB.AbstractMesh\n\nnD grid with netcdf CF1.0 coordinates, using n-dimensional Arrays for PALEO internal representation of Variables\n\nFields\n\nncells::Int64: number of cells in Domain = length(linear_index) (may be subset of total points in prod(dims))\ndimnames::Vector{String}: names of dimensions (ordered list)\ndims::Vector{Int}: sizes of dimensions (ordered list)\ncoords::Vector{Vector{Float64}}: attached cell-centre coordinates for each dimension (ordered list)\ncoords_edges::Vector{Vector{Float64}}: attached cell-edge coordinates for each dimension (ordered list)\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#Subdomains","page":"Domains, Variables, Fields, and Data arrays.","title":"Subdomains","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"AbstractSubdomain","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.AbstractSubdomain","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.AbstractSubdomain","text":"AbstractSubdomain\n\nDefines the relationship between two PB.Domains by mapping indices in one Domain to related indices in the other, eg interior cells adjacent to a boundary.\n\nConcrete subtypes should implement:\n\nsubdomain_view\n\nsubdomain_indices\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes.Grids","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"BoundarySubdomain\nInteriorSubdomain\nsubdomain_view\nsubdomain_indices","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.BoundarySubdomain","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.BoundarySubdomain","text":"BoundarySubdomain <: PB.AbstractSubdomain\n\nA 2D subdomain corresponding to the 2D boundary Domain associated with a 3D interior Domain:\n\nindices[ibnd] is the index of the 3D interior cell corresponding to a 2D boundary cell ibnd.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.InteriorSubdomain","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.InteriorSubdomain","text":"InteriorSubdomain <: PB.AbstractSubdomain\n\nA 3D subdomain corresponding to the 3D interior Domain associated with a 2D boundary Domain: indices[iint] is either:\n\nmissing if iint is the index of an interior cell in the 3D Domain, or\nthe index of the 2D boundary Domain cell corresponding to the boundary-adjacent 3D interior Domain cell iint\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.subdomain_view","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.subdomain_view","text":"subdomain_view(values, subdomain::BoundarySubdomain) -> view\n\nCreate a view on values in an interior Domain to access cells corresponding to indices in a boundary Domain.\n\n\n\n\n\nsubdomain_view(values, subdomain::InteriorSubdomain) -> var\n\nReturn unmodified values from a boundary Domain, indices to access  from interior supplied by subdomain_indices\n\n\n\n\n\nsubdomain_view(values, subdomain::Nothing) -> values\n\nFallback when subdomain == nothing\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.subdomain_indices","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.subdomain_indices","text":"subdomain_indices(subdomain::BoundarySubdomain) -> nothing\n\nNo additional indices required to access Variables in an interior Domain from a boundary Domain (view created by subdomain_view is sufficient).\n\n\n\n\n\nsubdomain_indices(subdomain::InteriorSubdomain) -> indices\n\nReturn indices to access Variables in a boundary Domain from interior Domain (will have missing entries where interior cells do not correspond to boundary)\n\n\n\n\n\nsubdomain_indices(subdomain::Nothing) -> nothing\n\nfallback when subdomain == nothing\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#Regions,-Dimensions-and-Coordinates","page":"Domains, Variables, Fields, and Data arrays.","title":"Regions, Dimensions and Coordinates","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes.Grids","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"get_region","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Grids.get_region","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Grids.get_region","text":"get_region(grid::Union{PB.AbstractMesh, Nothing}, values; selectargs...) -> values_subset, (dim_subset::NamedDimension, ...)\n\nReturn the subset of values given by selectargs (Grid-specific keywords eg cell=, column=, ...) and corresponding dimensions (with attached coordinates).\n\n\n\n\n\nget_region(grid::Nothing, values) -> values[]\n\nFallback for Domain with no grid, assumed 1 cell\n\n\n\n\n\nget_region(grid::UnstructuredVectorGrid, values; cell) -> \n    values_subset, (dim_subset::NamedDimension, ...)\n\nKeywords for region selection:\n\ncell::Union{Int, Symbol}: an Int, or a Symbol to look up in cellnames\n\n\n\n\n\nget_region(grid::UnstructuredColumnGrid, values; column, [cell=nothing]) -> \n    values_subset, (dim_subset::NamedDimension, ...)\n\nKeywords for region selection:\n\ncolumn::Union{Int, Symbol}: (may be an Int, or a Symbol to look up in columnames)\ncell::Int: optional cell index within column, highest cell is cell 1\n\n\n\n\n\nget_region(grid::Union{CartesianLinearGrid{2}, CartesianArrayGrid{2}} , internalvalues; [i=i_idx], [j=j_idx]) ->\n    arrayvalues_subset, (dim_subset::NamedDimension, ...)\n\nKeywords for region selection:\n\ni::Int: optional, slice along first dimension\nj::Int: optional, slice along second dimension\n\ninternalvalues are transformed if needed from internal Field representation as a Vector length ncells, to an Array (2D if neither i, j arguments present, 1D if i or j present, 0D ie one cell if both present)\n\n\n\n\n\nget_region(grid::Union{CartesianLinearGrid{3}, CartesianArrayGrid{3}}, internalvalues; [i=i_idx], [j=j_idx]) ->\n    arrayvalues_subset, (dim_subset::NamedDimension, ...)\n\nKeywords for region selection:\n\ni::Int: optional, slice along first dimension\nj::Int: optional, slice along second dimension\nk::Int: optional, slice along third dimension\n\ninternalvalues are transformed if needed from internal Field representation as a Vector length ncells, to an Array (3D if neither i, j, k arguments present, 2D if one of i, j or k present, 1D if two present, 0D ie one cell if i, j, k all specified).\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Grids may define name dimensions and attach coordinates for the convenience of output visualisation. Any coordinate information required by Reactions should be supplied as Variables.","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"NamedDimension\nFixedCoord","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.NamedDimension","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.NamedDimension","text":"NamedDimension\n\nA named dimension, with optional attached fixed coordinates coords\n\nPALEO convention is that where possible coords contains three elements, for cell midpoints, lower edges, upper edges, in that order.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.FixedCoord","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.FixedCoord","text":"FixedCoord\n\nA fixed (state independent) coordinate\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#Variables","page":"Domains, Variables, Fields, and Data arrays.","title":"Variables","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"PALEO Variables exist in Domains and represent biogeochemical or other quantities. They are defined by Reactions as VariableReactions which are then linked to create VariableDomains, and contain Fields which represent data (a subtype of AbstractData) in a function space (a subtype of AbstractSpace) with dimensions defined by the Domain grid (a subtype of AbstractMesh)","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Dataflow dependency between Variables is represented by two pairings:","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"VariableReactions of VariableType VT_ReactProperty and VT_ReactDependency which are linked to create VariableDomPropDeps\nVariableReactions of VariableType VT_ReactTarget and VT_ReactContributor which are linked to create  VariableDomContribTargets.","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"VariableBase\nVariableType\nVariableDomain\nVariableDomPropDep\nVariableDomContribTarget","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.VariableBase","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariableBase","text":"VariableBase\n\nA Model biogeochemical Variable. Reactions access Variables using derived Types VariableReaction which are links to VariableDomains.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.VariableType","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariableType","text":"@enum VariableType\n\nEnumeration of VariableBase subtypes. Allowed values:\n\nVariableReaction: VT_ReactProperty, VT_ReactDependency, VT_ReactContributor, VT_ReactTarget\nVariableDomain : VT_DomPropDep, VT_DomContribTarget\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.VariableDomain","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariableDomain","text":"VariableDomain <: VariableBase\n\nAbstract base Type for a (Domain) model variable.\n\nDefines a named Variable and corresponding data Fields that are linked to by VariableReactions.\n\nSee VariableDomPropDep, VariableDomContribTarget \n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.VariableDomPropDep","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariableDomPropDep","text":"VariableDomPropDep <: VariableDomain\n\nModel (Domain) VariableDomain linking a single VariableReaction{VT_ReactProperty} to multiple VariableReaction{VT_ReactDependency}.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.VariableDomContribTarget","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariableDomContribTarget","text":"VariableDomContribTarget <: VariableDomain\n\nModel (Domain) VariableDomain linking a single VariableReaction{VT_ReactTarget} to multiple VariableReaction{VT_ReactContributor} and VariableReaction{VT_ReactDependency}.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#Variable-Attributes","page":"Domains, Variables, Fields, and Data arrays.","title":"Variable Attributes","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Attribute\nStandardAttributes","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Attribute","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Attribute","text":"Attribute{T}\n\nDefinition for Variable attribute name. Defines a data type T, a default_value, required (true if always present ie added with default_value when Variable is created), units, and an optional description.\n\nNote that Variable attributes are stored as a per-Variable Dict(name => value), these definitions are only used to provide defaults, check types, and provide descriptive metadata.\n\nParseFromString should usually be false: a value of Type T is then required when calling set_attribute!. If ParseFromString is true, then set_attribute! will accept an AbstractString and call Base.parse(T, strvalue) to convert to T. This allows eg an enum-valued Attribute to be defined by Attribute{EnumType, true} and implementing parse(EnumType, rawvalue::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.StandardAttributes","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.StandardAttributes","text":"StandardAttributes\n\nList of standard Variable attributes.\n\nSome of these follow netCDF COARDS/CF conventions:\n\nCOARDS:https://ferret.pmel.noaa.gov/Ferret/documentation/coards-netcdf-conventions\n\nunits   (where possible should follow the Unidata udunits package https://docs.unidata.ucar.edu/udunits/current/)\nlong_name\n\nCF conventions: https://cfconventions.org/cf-conventions/cf-conventions.html#_description_of_the_data\n\nstandard_name   http://cfconventions.org/Data/cf-standard-names/current/src/cf-standard-name-table.xml\n\n\n\n\n\n","category":"constant"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"import PALEOboxes as PB # hide\nimport DataFrames # hide\nshow( # hide\n    DataFrames.sort!( # hide\n        DataFrames.DataFrame((s=>getproperty.(PB.StandardAttributes, s) for s in (:name, :default_value, :required, :units, :description))...), # hide\n        [DataFrames.order(:required, rev=true), :name] # hide\n    ); # hide\n    allcols=true, allrows=true, truncate=96, show_row_number=false #hide\n) # hide","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"get_attribute\nVariableFunction\nVariablePhase","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.get_attribute","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.get_attribute","text":"get_attribute(var::VariableBase, name::Symbol, missing_value=missing) -> value\n\nGet Variable attribute.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.VariableFunction","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariableFunction","text":"@enum VariableFunction\n\nAllowed values of :vfunction Variable Attribute,  defining the Variable function to the host ODE or DAE solver.\n\nExplicit ODE problems with dS/dt = F(S) consist of pairs of S::VFStateExplicit, F::VFDeriv Variables.\n\nAn implicit ODE problem with dU/dt = F(U) where Total variables U are functions U(S) of State variables S will consist of pairs of U::VFTotal and F::VFDeriv Variables, and also the same number of S::VF_State (in  no particular order).\n\nAlgebraic constraints  C(S) = 0 include variables C::VFConstraint and the same number of S::VFState, with no corresponding VF_Deriv.\n\nNot all solvers support all combinations.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.VariablePhase","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.VariablePhase","text":"@enum VariablePhase\n\nAllowed values of :vphase Variable Attribute, defining the component phase this Variable belongs to  for multiphase cells.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"TODO standard Variable names.","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Use NetCDF CF standard names https://cfconventions.org/Data/cf-standard-names/76/build/cf-standard-name-table.html ?","category":"page"},{"location":"DomainsVariablesFields/#Fields","page":"Domains, Variables, Fields, and Data arrays.","title":"Fields","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Field, data and function space are defined by Variable Attributes in combination with an AbstractMesh","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":":field_data and optionally :data_dims define the subtype of AbstractData\n:space defines the subtype of AbstractSpace","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Examples:","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":":field_data = ScalarData, :space = ScalarSpace defines a Domain scalar (0D) quantity.\n:field_data = IsotopeLinear, :space = ScalarSpace defines a Domain scalar (0D) isotope quantity.\n:field_data = ScalarData, :space = CellSpace defines a per-cell quantity in a spatial Domain.\n:field_data = ArrayScalarData, :data_dims =(\"wgrid\",) :space = ScalarSpace defines a Domain scalar (0D) quantity on a wavelength grid, a Vector of length given by the value of the Domain \"wgrid\" data dimension (see set_data_dimension!)","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"Field\nget_field\nwrap_field","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.Field","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.Field","text":"Field{D <: AbstractData, S <: AbstractSpace, V, N, M}\n\nA Field of values::V of data type D defined on function space S over mesh::M and (optionally) with N data_dims::NTuple{N, NamedDimensions}.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.get_field","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.get_field","text":"get_field(obj, ...) -> Field\n\nGet Field from PALEO object obj\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.wrap_field","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.wrap_field","text":"create a new Field, containing supplied existing_values data arrays\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#Spaces","page":"Domains, Variables, Fields, and Data arrays.","title":"Spaces","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"AbstractSpace\nScalarSpace\nCellSpace\nColumnSpace","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.AbstractSpace","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.AbstractSpace","text":"AbstractSpace\n\nDefines a function space within a Domain, on a mesh defined by a Grid \n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.ScalarSpace","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.ScalarSpace","text":"ScalarSpace <: AbstractSpace\n\nA Domain position-independent quantity\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.CellSpace","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.CellSpace","text":"CellSpace <: AbstractSpace\n\nA per-cell quantity. Use as Variable attribute :space to create a Variable with data array dimensions from Grid cells.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.ColumnSpace","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.ColumnSpace","text":"ColumnSpace <: AbstractSpace\n\nA per-column quantity. Use as Variable attribute :space to create a Variable with data array dimensions from Grid columns.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#Data-types","page":"Domains, Variables, Fields, and Data arrays.","title":"Data types","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"AbstractData\nUndefinedData\nScalarData\nArrayScalarData\n\n\nallocate_values\ncheck_values\nzero_values!\ndof_values\nget_values_output\n\n\ninit_values!\ncopyfieldto!\ncopytofield!\nadd_field!\nadd_field_vec!\n\nnum_components(field_data::Type{<:AbstractData})\nget_components","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.AbstractData","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.AbstractData","text":"AbstractData\n\nDefines a Data type that can be composed with an AbstractSpace to form a Field\n\nConcrete subtypes should implement:\n\nallocate_values, check_values, zero_values!, dof_values, get_values_output\n\nIf the subtype needs to provide values for a numerical solver (eg as a state variable), it also needs to implement:\n\ninit_values!, copyfieldto!, copytofield!, add_field!, add_field_vec!\n\nIf the subtype has a representation as components, it should implement: num_components, get_components\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.UndefinedData","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.UndefinedData","text":"UndefinedData <: AbstractData\n\nUndefined data type (no methods implemented). Used to indicate that a Variable can link to any data type.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.ScalarData","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.ScalarData","text":"ScalarData <: AbstractData\n\nA Field scalar (eg a biogeochemical concentration)\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.ArrayScalarData","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.ArrayScalarData","text":"ArrayScalarData <: AbstractData\n\nAn Array of Field scalars (eg a intensity on a wavelength grid).\n\nNB: only implements minimal methods sufficient to allow use as a model internal variable, not as a state variable.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.allocate_values","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.allocate_values","text":"allocate_values(\n    field_data::Type{<:AbstractData}, data_dims::Tuple{Vararg{NamedDimension}}, data_type, space::Type{<:AbstractSpace}, spatial_size::Tuple;\n    thread_safe::Bool, allocatenans::Bool,\n) -> values\n\nallocate Field.values (eg an Array) for field_data with dimensions defined by spatial_size and data_dims\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.check_values","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.check_values","text":"check_values(\n    existing_values, \n    field_data::Type{<:AbstractData},\n    data_dims::Tuple{Vararg{NamedDimension}}, \n    data_type, \n    space::Type{<:AbstractSpace}, \n    spatial_size::Tuple{Integer, Vararg{Integer}}\n)\n\nCheck existing_values is of suitable type, size etc for use as Field.values, throw exception if not.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.zero_values!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.zero_values!","text":"zero_values!(values, field_data::Type{<:AbstractData}, data_dims::Tuple{Vararg{NamedDimension}}, space::Type{<:AbstractSpace}, cellrange)\n\nSet values over spatial region cellrange to zero at start of main loop \n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.dof_values","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.dof_values","text":"dof_values(\n    field_data::Type{<:AbstractData}, \n    data_dims::Tuple{Vararg{NamedDimension}}, \n    space::Type{<:AbstractSpace}, \n    mesh, \n    cellrange\n) -> dof::Int\n\nReturn degrees-of-freedom for field_data over spatial region cellrange.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.get_values_output","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.get_values_output","text":"Optional: sanitize values for storing as model output. Default implementation is usually OK - only implement eg for Atomic types that should be converted to standard types for storage\n\n\n\n\n\nsanitized version of values, suitable for storing as output\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.init_values!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.init_values!","text":"init_values!(\n    values, field_data::Type{<:AbstractData}, data_dims::Tuple{Vararg{NamedDimension}}, space::Type{<:AbstractSpace},\n    init_value::Symbol, attribv::VariableBase, convertfn, convertvalues, cellrange, info::NTuple{3, String}\n)\n\nInitialize values at model start to init_value over region cellrange using information from Variable attribv attributes, scaled by convertfn and convertvalues. \n\nOptional: only required if this field_data type is used for a model (state) Variable that requires initialisation.\n\nArguments:\n\nvalues: data to be zeroed\ninit_value::Symbol: one of :initialvalue, :normvalue, requesting type of initial value required\nattribv::VariableBase: Variable with attributes to use for initialisation\nconvertfn::Function:  apply multiplier convertfn(convertvalues, i) to initialisation value for cell i. Typically this is used to convert units eg concentration to mol.\nconvertvalues: parameters (if any) required by convertfn, eg a volume measure.\ncellrange: range of cells to initialise\ninfo::::NTuple{3, String}: Tuple (varinfo, convertinfo, trsfrinfo) of identifier strings to use for log messages\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.copyfieldto!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.copyfieldto!","text":"copyfieldto!(\n    dest,\n    doff, \n    values, \n    field_data::Type{<:AbstractData}, \n    data_dims::Tuple{Vararg{NamedDimension}}, \n    space::Type{<:AbstractSpace}, \n    cellrange\n) -> num_copied::Int\n\nCopy Field.values values from spatial region defined by cellrange, to dest Array starting at index doff.\n\nNumber of values over whole Domain should equal degrees-of-freedom returned by dof_values\n\nRequired if this field_data type needs to provide values for a numerical solver.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.copytofield!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.copytofield!","text":"copytofield!(\n    values,\n    field_data::Type{<:AbstractData},\n    data_dims::Tuple{Vararg{NamedDimension}},\n    space::Type{<:AbstractSpace},\n    cellrange, \n    src, \n    soff\n) -> num_copied::Int\n\nCopy from src Array starting at index soff to Field.values values for spatial region defined by cellrange.\n\nNumber of values over whole Domain should equal degrees-of-freedom returned by dof_values\n\nRequired if this field_data type needs to provide values for a numerical solver.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.add_field!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.add_field!","text":"add_field!(obj, f::Field ...)\n\nAdd Field or Field to PALEO object obj\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.add_field_vec!","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.add_field_vec!","text":"add_field_vec!(\n    dest, \n    field_data::Type{<:AbstractData}, \n    data_dims::Tuple{Vararg{NamedDimension}}, \n    space::Type{<:AbstractSpace}, \n    a, \n    cellrange,\n    src, \n    soff\n) -> num_added::Int\n\nImplement dest += a*src where dest is a Field.values, src is an Array, a is a number, over region defined by cellrange, starting at index soff in src.\n\nReturns number of elements of src used.\n\nSee  copytofield!, copyfieldto! for the relationship between Array src and Field values dest.\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.num_components-Tuple{Type{var\"#s6\"} where var\"#s6\"<:PALEOboxes.AbstractData}","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.num_components","text":"num_components(field_data::Type{<:AbstractData}) -> Int\n\nget number of components (optional - implement if field_data has a representation as components)\n\n\n\n\n\n","category":"method"},{"location":"DomainsVariablesFields/#PALEOboxes.get_components","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.get_components","text":"get_components(values, field_data::Type{<:AbstractData}) -> Vector\n\nConvert Field values to a Vector of components (optional - implement if field_data has a representation as components)\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#Isotopes","page":"Domains, Variables, Fields, and Data arrays.","title":"Isotopes","text":"","category":"section"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"DomainsVariablesFields/","page":"Domains, Variables, Fields, and Data arrays.","title":"Domains, Variables, Fields, and Data arrays.","text":"AbstractIsotopeScalar\n\nIsotopeLinear\n\nisotope_totaldelta\nget_total\nget_delta","category":"page"},{"location":"DomainsVariablesFields/#PALEOboxes.AbstractIsotopeScalar","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.AbstractIsotopeScalar","text":"AbstractIsotopeScalar <: AbstractData\n\nAn IsotopeScalar represents a quantity or flux with isotopic composition. Can be added, subtracted, multiplied by a scalar, and decomposed into components with the same (bulk) transport properties.\n\nImplementation\n\nEach IsotopeScalar should be added to IsotopeTypes, and implement:\n\nget_total(is::IsotopeScalar) -> total\narithmetic operations +/- (ie IsotopeScalars can be added and subtracted) and *number, /number  (IsotopeScalars can be scaled by a real number).\nmethods of the AbstractData interface\n\nand optional isotope-specific functions, eg for a single isotope:\n\nisotope_totaldelta(::Type{<: IsotopeScalar}, total, delta) -> IsotopeScalar()\nget_delta(is::IsotopeScalar) -> delta\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.IsotopeLinear","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.IsotopeLinear","text":"IsotopeLinear <: AbstractIsotopeScalar\n\nLinearized representation of isotopic composition, where  moldelta = total * delta.\n\n\n\n\n\n","category":"type"},{"location":"DomainsVariablesFields/#PALEOboxes.isotope_totaldelta","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.isotope_totaldelta","text":"isotope_totaldelta(::Type{IsotopeLinear}, total, delta) -> IsotopeLinear\n\nCreate an IsotopeLinear from total and delta\n\nExamples:\n\njulia> a = PB.isotope_totaldelta(PB.IsotopeLinear, 10.0, -2.0)\n(v=10.0, v_moldelta=-20.0, ‰=-2.0)\n\njulia> b = a*2\n(v=20.0, v_moldelta=-40.0, ‰=-2.0)\n\njulia> c = a + b\n(v=30.0, v_moldelta=-60.0, ‰=-2.0)\n\njulia> PB.get_total(c)\n30.0\n\njulia> PB.get_delta(c)\n-2.0\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.get_total","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.get_total","text":"generic get_total for non-isotope variable\n\n\n\n\n\nget_total(is::IsotopeLinear)\n\nGet isotope total\n\n\n\n\n\n","category":"function"},{"location":"DomainsVariablesFields/#PALEOboxes.get_delta","page":"Domains, Variables, Fields, and Data arrays.","title":"PALEOboxes.get_delta","text":"get_delta(is::IsotopeLinear)\n\nGet isotope delta (per mil)\n\n\n\n\n\n","category":"function"},{"location":"ReactionCatalog/#Generic-Reaction-catalog","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"PALEOboxes includes a catalog of generic Reactions as a starting point for model construction.","category":"page"},{"location":"ReactionCatalog/#Reservoirs","page":"Generic Reaction catalog","title":"Reservoirs","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes.Reservoirs","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"ReactionReservoirScalar\nReactionReservoir\nReactionReservoirWellMixed\nReactionReservoirConst\nReactionReservoirForced\nReactionConst","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReactionReservoirScalar","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReactionReservoirScalar","text":"ReactionReservoirScalar\n\nA single scalar biogeochemical reservoir with optional paired isotope reservoir, for use in a 0D Domain  (eg sedimentary or ocean reservoirs for COPSE N. M. Bergman, Timothy M Lenton, Andrew J Watson (2004)).\n\nCreates State and associated Variables, depending on parameter settings:\n\nconst=false: usual case, create state variable R (units mol, with attribute vfunction=VF_StateExplicit) and R_sms (units mol yr-1, with attribute vfunction=VF_Deriv).\nconst=true: a constant value, create R (a Property), and R_sms (a Target)\n\nIn addition:\n\na Property R_norm (normalized value) is always created.\nif parameter field_data <: AbstractIsotopeScalar (eg IsotopeLinear), a Property R_delta is created.\n\nThe local name prefix R should then be renamed using variable_links: in the configuration file.\n\nInitialisation\n\nInitial and norm value is set in the variable_attributes: section in    the configuration file, using R:initial_value, R:initial_delta, and R:norm_value.\n\nExample configuration in .yaml file\n\n            reservoir_P:  # 0D ocean Phosphorus\n                class: ReactionReservoirScalar\n                parameters:\n                    # field_data: ScalarData        # change to IsotopeLinear to represent an isotope\n                    # const: false                  # true to fix to constant value\n                variable_links:\n                    R*: P                           # rename to represent Phosphorus\n                variable_attributes:\n                    R:norm_value:           3.1e15  # mol \n                    R:initial_value:        3.1e15  # mol\n\nSee also\n\nReactionReservoir (one value per cell for a spatially resolved Domain eg ocean), ReactionReservoirWellMixed (one value for a whole spatially resolved Domain).\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\nconst[Bool]=false, default_value=false, description=\"true to provide a constant value: R is not a state variable, fluxes in R_sms Variable are ignored\"\n\nMethods and Variables for default Parameters\n\nmethodfn_do_nothing\nR_sms  (mol yr-1), VT_ReactContributor, VF_Deriv, description=\"scalar reservoir source-sinks\"\ndo_reactionreservoirscalar\nR  (mol), VT_ReactDependency, VF_StateExplicit, description=\"scalar reservoir\"\nR_norm  (), VT_ReactProperty, description=\"scalar reservoir normalized\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReactionReservoir","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReactionReservoir","text":"ReactionReservoir,  ReactionReservoirTotal\n\nA single (vector) reservoir (state variable) representing a biogeochemical tracer, ie one value per cell in a spatially-resolved Domain (eg ocean).\n\nState Variables created depend on parameters:\n\nstateexplicit=true: usual case to represent an ODE variable and time derivative, create state variable  R (mol m-3, with attribute vfunction=VF_StateExplicit) and R_sms (mol m-3 yr-1, with attribute vfunction=VF_Deriv).\nstateexplicit=false: for use with an ODE implicit state variable, create R_sms (with attribute vfunction=VF_Deriv) and a Dependency R (which  should be linked to a Variable with attribute vfunction=VF_Total calculated elsewhere, this Variable should also set the initial value). \n\nIn addition:\n\na Property R_conc (concentration in mol m-3) is always created.\nif parameter field_data <: AbstractIsotopeScalar (eg IsotopeLinear), a Property R_delta is created.\nReactionReservoirTotal also calculates the Domain total R_total (units mol), eg to check budgets.\n\nLocal name prefix R should then be renamed using variable_links: in the configuration file.\n\nInitialisation\n\nInitial value is set using variable_attributes: in the configuration file, using R:initial_value and R:initial_delta (NB: although initial_value is set on R, it sets concentration in mol m-3.)\n\nTransport is defined by attributes :advect, :vertical_movement (m d-1) set on the concentration variable R_conc. Optical extinction is defined by the :specific_light_extinction (m^2 mol-1) attribute set on the concentration variable R_conc.\n\nExample configuration in .yaml file\n\n            reservoir_P:  # ocean Phosphorus\n                class: ReactionReservoirTotal       # include _total (mol)\n                parameters:\n                    # field_data: ScalarData        # change to IsotopeLinear to represent an isotope                       \n                variable_links:\n                    R*: P                           # rename to represent Phosphorus\n                variable_attributes:\n                    R:norm_value:           3e-3    # mol m-3, normalisation value (used by some solvers)\n                    R:initial_value:        2e-3    # mol m-3, initial concentration\n\nSee also\n\nReactionReservoirWellMixed (one value for the whole Domain), ReactionReservoirScalar (one value for a reservoir in a 0D Domain eg for COPSE N. M. Bergman, Timothy M Lenton, Andrew J Watson (2004)), ReactionReservoirConst (constant time-independent value ie no state variable). \n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\ntotal[Bool]=false, default_value=false, description=\"true to calculate R_total\"\nlimit_delta_conc[Float64]=0.0  (mol m-3), default_value=0.0, description=\"**EXPERIMENTAL** attempt to limit delta for low/-ve concentrations (0.0 to disable)\"\nstateexplicit[Bool]=true, default_value=true, description=\"true to define a StateExplicit Variable, false to just calculate conc etc from eg a Total Variable defined elsewhere\"\n\nMethods and Variables for default Parameters\n\nmethodfn_do_nothing\nR_sms  (mol yr-1), VT_ReactContributor, VF_Deriv, description=\"vector reservoir source-sinks\"\ndo_reactionreservoir\nR  (mol), VT_ReactDependency, VF_StateExplicit, description=\"vector reservoir\"\nvolume  (m3), VT_ReactDependency, description=\"cell volume (or cell phase volume eg for a sediment with solid and liquid phases)\"\nR_conc  (mol m-3), VT_ReactProperty, description=\"concentration\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReactionReservoirWellMixed","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReactionReservoirWellMixed","text":"ReactionReservoirWellMixed\n\nA Scalar Reservoir representing a well-mixed tracer in a vector Domain (eg ocean). Provides a scalar state Variable R and R_sms, and also vector Variables: R_conc (set to uniform concentration), and R_vec_sms Target for accumulating fluxes that is added to the scalar R_sms. \n\nInitialisation\n\nInitial value is set in the variable_attributes: section in the configuration file, using R:initial_value and R:initial_delta. NB: may be initialized either from mean concentration or total (set by parameter initialization_type)\n\nTODO salinity normalisation.\n\nSee also\n\nReactionReservoir (one value per cell), ReactionReservoirScalar (one value for a reservoir in a 0D Domain eg for COPSE N. M. Bergman, Timothy M Lenton, Andrew J Watson (2004)).\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\ninitialization_type[String]=\"conc\", default_value=\"conc\", allowed_values=[\"conc\", \"total\"], description=\":initial_value attribute represents conc (mol m-3) or total (mol)\"\n\nMethods and Variables for default Parameters\n\ndo_reservoir_well_mixed\nR  (mol), VT_ReactDependency, VF_StateExplicit, description=\"scalar reservoir\"\nR_norm  (), VT_ReactProperty, description=\"scalar reservoir normalized\"\nR_conc  (mol m-3), VT_ReactProperty, description=\"concentration\"\nvolume_total  (m^3), VT_ReactDependency, description=\"total volume\"\ndo_reservoir_well_mixed_sms\nR_sms  (mol yr-1), VT_ReactContributor, VF_Deriv, description=\"scalar reservoir source-sinks\"\nR_vec_sms  (mol yr-1), VT_ReactTarget, description=\"vector reservoir source-sinks\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReactionReservoirConst","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReactionReservoirConst","text":"ReactionReservoirConst\n\nA single (vector) constant tracer R_conc (constant replacement for a ReactionReservoir).\n\nLocal name prefix R should then be renamed using variable_links: in the configuration file.\n\nInitialisation\n\nSet :initial_value, :initial_delta on R_conc (mol m-3) in the variable_attributes: section of the config file.\n\nTODO salinity normalisation.\n\nExample configuration in .yaml file\n\n            reservoir_B:  # Constant value for ocean Boron \n                class: ReactionReservoirConst\n                parameters:\n                    field_data: IsotopeLinear\n                variable_links:\n                    R*: B\n                variable_attributes:                      \n                    R_conc:initial_value:       0.4269239 # contemporary value\n                    R_conc:initial_delta:       34.0\n\nSee also\n\nReactionReservoir\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\n\nMethods and Variables\n\nsetup_initialvalue_vars_default\nR_conc  (mol m-3), VT_ReactProperty, description=\"concentration\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReactionReservoirForced","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReactionReservoirForced","text":"ReactionReservoirForced\n\nA single (vector) constant tracer (constant replacement for a ReactionReservoir), with forcing.\n\nCalculates R_conc = R_conc_initial * R_FORCE.\n\nLocal name prefix R should then be renamed using variable_links: in the configuration file.\n\nInitialisation\n\nNB: set :initial_value, :initial_delta on R_conc_initial in the variable_attributes: section of the config file.\n\nTODO salinity normalisation.\n\nSee also\n\nReactionReservoirConst, ReactionReservoir\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\n\nMethods and Variables for default Parameters\n\ndo_reactionreservoirconstforced\nR_conc_initial  (mol m-3), VT_ReactProperty, description=\"initial concentration\"\nR_conc  (mol m-3), VT_ReactProperty, description=\"concentration = initial * forcing\"\nR_FORCE  (), VT_ReactDependency, description=\"forcing factor\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReactionConst","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReactionConst","text":"ReactionConst, ReactionScalarConst\n\nCreate constant Property Variables with names from parameter constnames. \n\nInitialisation\n\nConstant values set by :initial_value, :initial_delta attributes in the variable_attributes: section of the configuration file.\n\nExample configuration in .yaml file\n\n    atmfloor:\n        reactions:                \n            floorstubgasmr:  # Provide mixing-ratio boundary condition for a subset of atmospheric variables\n                class: ReactionConst\n                parameters:\n                    constnames: [\"O2_mr\", \"CH4_mr\", \"CO2_mr\", \"H2_mr\"] #, \"H2O_mr\"]  \n                variable_attributes:        \n                    O2_mr:initial_value:  [0.21]  # mol/mol\n                    CH4_mr:initial_value:  [0.7443e-6] # [.NaN] # [1.271e-6] # [1.8e-6]  # mol/mol\n                    CO2_mr:initial_value:  [300e-6]  # mol/mol\n                    H2_mr:initial_value:   [.NaN]  # mol/mol\n\nSee also\n\nReactionReservoirConst, ReactionReservoirScalar.  These provide additional variables (eg R_delta) to  allow them to function as a drop-in replacement for a non-constant Reservoir.\n\nParameters\n\nconstnames[Vector{String}]=[\"constvar\"], default_value=[\"constvar\"], description=\"vector of names for constant Variables. Isotopes use <name>::CIsotope syntax\"\n\nMethods and Variables for default Parameters\n\nsetup_initialvalue_vars_default\nconstvar  (), VT_ReactProperty, description=\"constant value\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#Linking-to-Reservoirs-from-a-Reaction","page":"Generic Reaction catalog","title":"Linking to Reservoirs from a Reaction","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"ReservoirLinksVector","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.Reservoirs.ReservoirLinksVector","page":"Generic Reaction catalog","title":"PALEOboxes.Reservoirs.ReservoirLinksVector","text":"ReservoirLinksVector(isotope_data::Dict, reservoirlist) -> (res::Vector, sms::Vector, diag::Vector)\n\nConvenience function to create variables required for a Reaction to link to a list of Reservoir variables. res contains VariableReactions <reservoir_name>, sms <reservoir_name>_sms that link to State, State_sms variables. diag contains VariableReactions <reservoir_name>_norm etc that link to additional properties.\n\nArguments\n\nreservoirlist::[(reservoir_name[::Isotope],       units,   description), ...]: list of Reservoirs\n\n\n\n\n\n","category":"function"},{"location":"ReactionCatalog/#Variable-Statistics","page":"Generic Reaction catalog","title":"Variable Statistics","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes.VariableStats","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"ReactionSum\nReactionWeightedMean\nReactionAreaVolumeValInRange","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.VariableStats.ReactionSum","page":"Generic Reaction catalog","title":"PALEOboxes.VariableStats.ReactionSum","text":"ReactionSum, ReactionVectorSum\n\nA sum of variables (eg budget).\n\nIf Parameter component_to_add == 0, all components of Isotopes are included.\nIf Parameter component_to_add == component_number, a single component only is included.\n\nParameters\n\nvars_to_add[Vector{String}]=[\"2\\myvar\", \"myothervar\", \"-1\\mythirdvar\"], default_value=[\"2\\myvar\", \"myothervar\", \"-1\\mythirdvar\"], description=\"vector of variable names to add, eg [2*myvar, myothervar, -1*mythirdvar]\"\nvars_prefix[String]=\"\", default_value=\"\", description=\"optional prefix for vars_to_add\"\ncomponent_to_add[Int64]=0, default_value=0, description=\"component to add, 0 for all\"\nvectorsum[Bool]=false, default_value=false, description=\"true to accumulate sum into vector Variable, false to accumulate sum into scalar (adding vector cells if necessary)\"\n\nMethods and Variables for default Parameters\n\ndo_scalarsum\nsum  (), VT_ReactProperty, description=\"sum of specified variables\"\n[myvar]  (), VT_ReactDependency, description=\"\"\n[myothervar]  (), VT_ReactDependency, description=\"\"\n[mythirdvar]  (), VT_ReactDependency, description=\"\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.VariableStats.ReactionWeightedMean","page":"Generic Reaction catalog","title":"PALEOboxes.VariableStats.ReactionWeightedMean","text":"ReactionWeightedMean\n\nWeighted mean (eg by area or volume) of Variable\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\n\nMethods and Variables\n\ndo_weighted_mean\nvar  (measure-1), VT_ReactDependency, description=\"variable to calculate weighted mean from\"\nmeasure  (), VT_ReactDependency, description=\"cell area or volume\"\nmeasure_total  (), VT_ReactDependency, description=\"total Domain area or volume\"\nvar_mean  (), VT_ReactProperty, description=\"weighted mean over Domain area or volume\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.VariableStats.ReactionAreaVolumeValInRange","page":"Generic Reaction catalog","title":"PALEOboxes.VariableStats.ReactionAreaVolumeValInRange","text":"ReactionAreaVolumeValInRange\n\nFraction of Domain area or volume with Variable in a range of values.\n\nParameters\n\nrange_min[Float64]=-Inf  (mol m-3), default_value=-Inf, description=\"minimum value to include in frac\"\nrange_max[Float64]=Inf  (mol m-3), default_value=Inf, description=\"maximum value to include in frac\"\n\nMethods and Variables\n\ndo_area_volume_in_range\nrangevar  (mol m-3), VT_ReactDependency, description=\"variable to check within range\"\nmeasure  (), VT_ReactDependency, description=\"cell area or volume\"\nmeasure_total  (), VT_ReactDependency, description=\"total Domain area or volume\"\nfrac  (), VT_ReactProperty, description=\"fraction of Domain area or volume in specified range\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#Fluxes","page":"Generic Reaction catalog","title":"Fluxes","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"Fluxes","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.Fluxes","page":"Generic Reaction catalog","title":"PALEOboxes.Fluxes","text":"Fluxes\n\nCreate and manage collections of Target and Contrib Variables used to define fluxes within or between Domains.\n\nConventions for defining biogeochemical fluxes within Domains\n\nParticulate organic matter (including CaCO3) with stoichiometry Corg:N:P:Ccarb is usually transferred as: flux_list [\"P\", \"N\", \"Corg::CIsotope\", \"Ccarb::CIsotope\"] with a prefix indicating the function (eg export_).\nSolute fluxes are usually transferred as: flux_list  [\"DIC::CIsotope\", \"TAlk\", \"Ca\", \"P\", \"O2\", \"SO4::SIsotope\", \"H2S::SIsotope\", \"CH4::CIsotope\"] (where these names match the Reservoir names for the solutes), with a prefix indicating the function (usually just flux_ or soluteflux_).\n\nConventions for defining global fluxes between modules\n\nThe model configuration .yaml file should create  a Domain for each global flux, containing one or more Fluxes.ReactionFluxTarget.  Fluxes are then transferred (copied) by adding a Fluxes.ReactionFluxTransfer to each destination Domain.\n\nNaming conventions for Earth system fluxes:\n\nDomain name target prefix flux_list (illustrative, add as needed)\nfluxAtoLand flux_ [\"CO2::CIsotope\", \"O2\"]\nfluxRtoOcean flux_ [\"DIC::CIsotope\", \"TAlk\", \"Ca\", \"P\", \"SO4::SIsotope\"]\nfluxOceanBurial flux_ [\"Corg::CIsotope\", \"Ccarb::CIsotope\", \"Porg\", \"Pauth\", \"PFe\", \"P\", \"GYP::SIsotope\", \"PYR::SIsotope\"]\nfluxSedCrusttoAOcean flux_ [\"C::CIsotope\", \"S::SIsotope\", \"Redox\"]\nfluxLandtoSedCrust flux_ [\"Ccarb::CIsotope\", \"Corg::CIsotope\", \"GYP::SIsotope\", \"PYR::SIsotope\"]\nfluxOceanfloor particulateflux_ [\"P\", \"N\", \"Corg::CIsotope\", \"Ccarb::CIsotope\"]\n soluteflux_ [\"DIC::CIsotope\", \"TAlk\", \"Ca\", \"P\", \"O2\", \"SO4::SIsotope\", \"H2S::SIsotope\", \"CH4::CIsotope\"]\nfluxAtmtoOceansurface flux_ [\"CO2::CIsotope\", \"CH4::CIsotope\", \"O2\"]\n\n\n\n\n\n","category":"module"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes.Fluxes","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"ReactionFluxTarget\nReactionFluxTransfer","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.Fluxes.ReactionFluxTarget","page":"Generic Reaction catalog","title":"PALEOboxes.Fluxes.ReactionFluxTarget","text":"ReactionFluxTarget\n\nProvides either a target for fluxes from fluxlist in an input Domain or a constant stub, optionally calculates totals.\n\nFor each fluxname in fluxlist, creates:\n\nif const_stub==false, an input VarTarget pars.target_prefix[]*\"flux_\"*fluxname (or if const_stub==true, a constant VarProp).\nif flux_totals is true, a total VarPropScalar target_prefix[]*\"flux_total_\"*fluxname.\n\nParameters\n\nfluxlist[Vector{String}]=[\"example\"], default_value=[\"example\"], description=\"available fluxes\"\ntarget_prefix[String]=\"flux_\", default_value=\"flux_\", description=\"target names will be \"<target_prefix><fluxname>\",                            target total names will be \"<target_prefix>total_<fluxname>\"               (where <fluxname> is an entry in fluxlist)\"\nflux_totals[Bool]=false, default_value=false, description=\"true to calculate flux totals (as \"<target_prefix>flux_total_<fluxname>\")\"\nconst_stub[Bool]=false, default_value=false, description=\"true to provide constant flux defined by :initial_value, :initial_delta attributes on input Target Variables \"<target_prefix>flux_<fluxname>\"\"\n\nMethods and Variables for default Parameters\n\nmethodfn_do_nothing\nflux_example  (mol yr-1), VT_ReactTarget, description=\"flux input\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.Fluxes.ReactionFluxTransfer","page":"Generic Reaction catalog","title":"PALEOboxes.Fluxes.ReactionFluxTransfer","text":"ReactionFluxTransfer\n\nCopy fluxes, optionally using transfer matrices to define cell-cell mappings if input and output fluxes  are in a different Domain.\n\nThere are three common cases:\n\nTransfer within a Domain, using transfer_matrix Identity\nTransfer from a fluxXXX Domain to the Domain hosting the ReactionFluxTransfer, using transfer_matrix to define a mapping if these Domains are of different sizes.  \nTransfer from a fluxXXX Domain to the boundary cells of an interior Domain (eg ocean.oceansurface),  where the Domain hosting the ReactionFluxTransfer is the corresponding boundary Domain (eg oceansurface).\n\nFlux names\n\nThe list of flux names is generated by finding all names that match the pattern supplied to input_fluxes, so\n\nparameters:\n    input_fluxes:  fluxAtmtoOceansurface.flux_$fluxname$\n    output_fluxes:  ocean.oceansurface.$fluxname$_sms\n\nwill:\n\nMatch eg fluxAtmtoOceansurface.flux_CO2, fluxAtmtoOceansurface.flux_O2 and generate names CO2, O2.\nGenerate variables with Reaction-local names input_CO2, input_O2, and link names configured to link to the input fluxes\nGenerate variables with Reaction-local names output_CO2, output_O2, and link names configured to link to the output flux  names generated by substituting $fluxname$ in output_fluxes.\n\nThis handles the common case eg O2 where the names of the input and output fluxes match. However, if they don't match, eg the input flux is called CO2 and the output flux should be applied to DIC, then it is necessary to use variable_links: to change the link name for output_CO2 to DIC.\n\nParameters\n\ninput_fluxes[String]=\"[inputdomain.][inputsubdomain.]flux_$fluxname$\", default_value=\"[inputdomain.][inputsubdomain.]flux_$fluxname$\", description=\"string to match to find input flux Variables. These Variables will local names \"input_$fluxname$\".\"\noutput_fluxes[String]=\"[outputdomain.][outputsubdomain.]$fluxname$_sms\", default_value=\"[outputdomain.][outputsubdomain.]$fluxname$_sms\", description=\"string to use to generate output flux Variables where $fluxname$ is substituted from input_fluxes. These Variables will local names \"output_$fluxname$\", and are optional (ie ignored if not linked). Usually the output Domain is the Domain hosting the ReactionFluxTransfer (in general, it must be a Domain of the same size as the Domain hosting the ReactionFluxTransfer).\"\ntransfer_multiplier[Float64]=1.0, default_value=1.0, description=\"scalar multiplier for transfer\"\ntransfer_matrix[String]=\"Identity\", default_value=\"Identity\", allowed_values=[\"Identity\", \"Distribute\", \"Custom\"], description=\"matrix defining input Domain (length n) -> output Domain (length m) mapping:                'Identity' copies fluxes directly, requires m == n;                'Distribute' uniformly distributes fluxes from input->output: sums over n and them distributes fraction 1/m evenly to each m;               'Custom' requires transfer matrix to be supplied\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#Contributing-to-flux-couplers-from-a-Reaction","page":"Generic Reaction catalog","title":"Contributing to flux couplers from a Reaction","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"FluxContrib","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.Fluxes.FluxContrib","page":"Generic Reaction catalog","title":"PALEOboxes.Fluxes.FluxContrib","text":"FluxContrib(\n    fluxprefix::AbstractString, flux_list;\n    [, isotope_data::Dict]\n    [, space=PB.CellSpace][, alloptional=true]\n) -> vartuple::NamedTuple\n\nCreate a NamedTuple of VarContrib from flux_prefix.*flux_list, needed for a Reaction to write to a flux coupler. Entries in flux_list of form fluxname::isotope are parsed to look up isotope type from isotope_data Dict.\n\nFor each fluxname in flux_list, the generated VarContrib vartuple.fluxname have link_namestr=$(fluxprefix)$(fluxname)\" and  localname=\"$(fluxprefix)$(fluxname) (with any . in fluxprefix substituted to _).\n\nExample:\n\njulia> fluxRtoOcean = PB.Fluxes.FluxContrib(\"fluxRtoOcean.flux_\", [\"P\", \"SO4::SIsotope\"], isotope_data=Dict(\"SIsotope\"=>PB.IsotopeLinear), space=PB.ScalarSpace);\n\njulia> fluxRtoOcean.P\nPALEOboxes.VariableReaction{PALEOboxes.VT_ReactContributor}\n  localname='fluxRtoOcean_flux_P'\n  link_name='fluxRtoOcean.flux_P[unlinked]'\n  attributes=Dict{Symbol, Any}(:description => \"flux P\", :space => PALEOboxes.ScalarSpace, :standard_variable => false, :norm_value => 1.0, :data_dims => String[], :long_name => \"\", :vfunction => PALEOboxes.VF_Undefined, :field_data => PALEOboxes.ScalarData, :initial_delta => 0.0, :units => \"mol yr-1\"…)\n\njulia> fluxRtoOcean.SO4\nPALEOboxes.VariableReaction{PALEOboxes.VT_ReactContributor}\n  localname='fluxRtoOcean_flux_SO4'\n  link_name='fluxRtoOcean.flux_SO4[unlinked]'\n  attributes=Dict{Symbol, Any}(:description => \"flux SO4\", :space => PALEOboxes.ScalarSpace, :standard_variable => false, :norm_value => 1.0, :data_dims => String[], :long_name => \"\", :vfunction => PALEOboxes.VF_Undefined, :field_data => PALEOboxes.IsotopeLinear, :initial_delta => 0.0, :units => \"mol yr-1\"…)\n\n\n\n\n\n","category":"function"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"ReactionCatalog/#Forcings","page":"Generic Reaction catalog","title":"Forcings","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"Forcings.ReactionForceInterp\nGridForcings.ReactionForceGrid\nFluxPerturb.ReactionFluxPerturb\nFluxPerturb.ReactionRestore","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.Forcings.ReactionForceInterp","page":"Generic Reaction catalog","title":"PALEOboxes.Forcings.ReactionForceInterp","text":"ReactionForceInterp\n\nProvide a scalar Property F, linearly interpolated from a table of values vs time tforce.\n\nThe table of values is set by parameters force_times and force_value.\n\nThe input time Variable is tforce, with default linking to the global.tforce Variable.\n\nUse the configuration file to rename the output variable F (and if necessary, the input Variable tforce).\n\nNB: no extrapolation ! (so eg set guard values for force_times at -1e30, 1e30)\n\nParameters\n\nforce_times[Vector{Float64}]=[-1.0e30, 1.0e30]  (yr), default_value=[-1.0e30, 1.0e30], description=\"interpolated forcing times\"\nforce_values[Vector{Float64}]=[1.0, 1.0], default_value=[1.0, 1.0], description=\"interpolated forcing values\"\n\nMethods and Variables\n\ndo_forceinterp\ntforce –> global.tforce  (yr), VT_ReactDependency, description=\"historical time at which to apply forcings, present = 0 yr\"\nF  (), VT_ReactProperty, description=\"interpolated forcing\"\n\n\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.GridForcings.ReactionForceGrid","page":"Generic Reaction catalog","title":"PALEOboxes.GridForcings.ReactionForceGrid","text":"ReactionForceGrid\n\nApply time-dependent, periodic forcing from a variable in a netcdf or Matlab file, optionally applying a scaling, a constant linear offset, and a linear offset generated from a scalar model variable.\n\nReads records tidx_start:tidx_end (assumed to be the last dimension) for data_var from a gridded dataset in netcdf_file or matlab_file, maps grid to linear using the Domain grid (which must match that of data_var).\n\nIf tidx_end > tidx_start (ie multiple records), reads a netcdf or Matlab variable named time_var, applies periodicity cycle_time, and uses this to linearly interpolate to model time.\n\nThen applies forcing:\n\nF = scale*`data_var` + constant_offset + scale_offset_var*`scalar_offset_var`\n\nOptionally (if interp_vars is non-empty), interpolate forcing from additional dimensions in the netcdf file, given values supplied by additional Variable dependencies. NB: netcdf dimensions order must be grid_vars x interp_varsxtimevar, where order withininterpvars` also must match netcdf order.\n\nParameters\n\nnetcdf_file[String]=\"\", default_value=\"\", description=\"netcdf file with gridded time-series data\"\nmatlab_file[String]=\"\", default_value=\"\", description=\"matlab file with gridded time-series data\"\ndata_var[String]=\"\", default_value=\"\", description=\"variable name in data file\"\ntime_var[String]=\"time\", default_value=\"time\", description=\"time variable name in data file (empty to generate evenly spaced times from cycle_time)\"\ntidx_start[Int64]=1, default_value=1, description=\"first record in data file to use\"\ntidx_end[Int64]=1, default_value=1, description=\"last record in data file to use (set equal to tidx_start for constant forcing from single record)\"\nuse_timeav[Bool]=false, default_value=false, description=\"true to average records and provide constant forcing at time-averaged value\"\ncycle_time[Float64]=1.0  (yr), default_value=1.0, description=\"time periodicity to apply (0.0 to disable periodic)\"\ninterp_vars[Vector{String}]=String[], default_value=String[], description=\"optional interpolation variables for additional grid dimensions. NB: netcdf dimensions order must be grid_vars x interp_vars x time_var, where order within interp_vars also must match netcdf order\"\ninterp_log[Vector{Bool}]=Bool[], default_value=Bool[], description=\"true to interpolate interp_vars in log space\"\nscale[Float64]=1.0, default_value=1.0, description=\"scaling factor to apply\"\nconstant_offset[Float64]=0.0, default_value=0.0, description=\"constant offset to apply\"\nscale_offset_var[Float64]=0.0, default_value=0.0, description=\"scaling for additional scalar offset from model variable (0.0 to disable)\"\n\nMethods and Variables for default Parameters\n\ndo_force_grid\ntforce –> global.tforce  (yr), VT_ReactDependency, description=\"historical time at which to apply forcings, present = 0 yr\"\nF  (), VT_ReactProperty, description=\"interpolated forcing\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.FluxPerturb.ReactionFluxPerturb","page":"Generic Reaction catalog","title":"PALEOboxes.FluxPerturb.ReactionFluxPerturb","text":"ReactionFluxPerturb\n\nProvide a scalar flux F, linearly interpolated from a table of values vs time tforce.\n\nThe table of values is set by parameters perturb_times and perturb_totals, and optionally perturb_deltas.\n\nThe input time Variable is tforce, with default linking to the global.tforce Variable.\n\nUse the configuration file to rename output variable F (and if necessary, the input Variable tforce).\n\nNB: no extrapolation ! (so eg set guard values for perturb_times at -1e30, 1e30)\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\nperturb_times[Vector{Float64}]=[-1.0e30, 1.0e30]  (yr), default_value=[-1.0e30, 1.0e30], description=\"interpolated perturbation times\"\nperturb_totals[Vector{Float64}]=[1.0, 1.0]  (mol yr-1), default_value=[1.0, 1.0], description=\"interpolated perturbation totals\"\nperturb_deltas[Vector{Float64}]=[0.0, 0.0]  (per mil), default_value=[0.0, 0.0], description=\"interpolated perturbation deltas\"\n\nMethods and Variables\n\ndo_flux_perturb\ntforce –> global.tforce  (yr), VT_ReactDependency, description=\"time at which to apply perturbation\"\nF  (mol yr-1), VT_ReactContributor, description=\"interpolated flux perturbation\"\nFApplied –> %reaction%FApplied  (mol yr-1), VT_ReactProperty, description=\"flux perturbation applied, for diagnostic output\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.FluxPerturb.ReactionRestore","page":"Generic Reaction catalog","title":"PALEOboxes.FluxPerturb.ReactionRestore","text":"ReactionRestore\n\nAdds RestoringFlux in response to discrepancy between Variable WatchLevel and Parameter RequiredLevel\n\nParameters\n\nfield_data[DataType]=PALEOboxes.ScalarData, default_value=PALEOboxes.ScalarData, allowed_values=Type[PALEOboxes.ScalarData, PALEOboxes.IsotopeLinear], description=\"disable / enable isotopes and specify isotope type\"\nRequiredLevel[Float64]=0.0  (mol), default_value=0.0, description=\"target value of WatchLevel\"\ntrestore[Float64]=1.0  (yr), default_value=1.0, description=\"restoring timescale\"\nRequiredDelta[Float64]=0.0  (per mil), default_value=0.0, description=\"target value of WatchLevel delta\"\nsource_only[Bool]=false, default_value=false, description=\"false to allow input and output, true to allow input only\"\n\nMethods and Variables\n\ndo_restore\nWatchLevel  (mol), VT_ReactDependency, description=\"level to observe and restore\"\nRestoringFlux  (mol yr-1), VT_ReactContributor, description=\"restoring flux\"\nRestoringApplied –> %reaction%RestoringApplied  (mol yr-1), VT_ReactProperty, description=\"restoring flux for diagnostic output\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#Grids","page":"Generic Reaction catalog","title":"Grids","text":"","category":"section"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"Minimal generic model grids for test purposes.","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"These just define the Domain size, and don't provide coordinate or metric information (cell volume, area).  Models will usually require a Reaction with a Domain-specific implementation (eg for ocean, atmosphere) that defines coordinates and volumes etc and also implements transport (advection, eddy diffusion, etc).","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"CurrentModule = PALEOboxes.GridReactions","category":"page"},{"location":"ReactionCatalog/","page":"Generic Reaction catalog","title":"Generic Reaction catalog","text":"ReactionUnstructuredVectorGrid\nReactionCartesianGrid\nReactionGrid2DNetCDF","category":"page"},{"location":"ReactionCatalog/#PALEOboxes.GridReactions.ReactionUnstructuredVectorGrid","page":"Generic Reaction catalog","title":"PALEOboxes.GridReactions.ReactionUnstructuredVectorGrid","text":"ReactionUnstructuredVectorGrid\n\nCreate an PB.Grids.UnstructuredVectorGrid with ncells (from ncells Parameter).\n\nParameters\n\nncells[Int64]=1, default_value=1, description=\"number of grid cells\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.GridReactions.ReactionCartesianGrid","page":"Generic Reaction catalog","title":"PALEOboxes.GridReactions.ReactionCartesianGrid","text":"ReactionCartesianGrid\n\nCreate a PB.Grids.CartesianArrayGrid with dims and dimnames`\n\nParameters\n\ndimnames[Vector{String}]=[\"lat\", \"lon\", \"z\"], default_value=[\"lat\", \"lon\", \"z\"], description=\"grid dimension names\"\ndims[Vector{Int64}]=[2, 3, 4], default_value=[2, 3, 4], description=\"grid dimensions\"\n\n\n\n\n\n","category":"type"},{"location":"ReactionCatalog/#PALEOboxes.GridReactions.ReactionGrid2DNetCDF","page":"Generic Reaction catalog","title":"PALEOboxes.GridReactions.ReactionGrid2DNetCDF","text":"ReactionGrid2DNetCDF\n\nCreate a 2D PB.Grids.CartesianLinearGrid from grid information in a NetCDF file.\n\nParameters\n\ngrid_type[UnionAll]=PALEOboxes.Grids.CartesianArrayGrid, default_value=PALEOboxes.Grids.CartesianArrayGrid, allowed_values=Type[PALEOboxes.Grids.CartesianArrayGrid, PALEOboxes.Grids.CartesianLinearGrid], description=\"Cartesian grid type to create\"\ngrid_file[String]=\"\", default_value=\"\", description=\"netcdf file with 2D grid information\"\ncoordinate_names[Vector{String}]=[\"longitude\", \"latitude\"], default_value=[\"longitude\", \"latitude\"], description=\"coordinate names to read from netcdf file\"\nequalspacededges[Bool]=false, default_value=false, description=\"true to calculate cell edges assuming an equal-spaced grid\"\narea_var[String]=\"\", default_value=\"\", description=\"netcdf variable with cell area (if available)\"\nplanet_radius[Float64]=6.371229e6, default_value=6.371229e6, description=\"radius to calculate cell area from spherical geometry (if area_var = \"\")\"\n\nMethods\n\nsetup_grid_2DNetCDF\nAsurf  (m^2), VT_ReactProperty, description=\"horizontal area of surface\"\nAsurf_total  (m^2), VT_ReactProperty, description=\"total horizontal area of surface\"\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#Solver-API","page":"Solver API","title":"Solver API","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"A Model contains Domains, each of which contain Variables defining Fields, and Reactions with ReactionMethods that operate on the Fields to calculate model time evolution.","category":"page"},{"location":"Solver API/#Create-and-initialise","page":"Solver API","title":"Create and initialise","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"create_model_from_config(config_file::AbstractString, configmodel::AbstractString)\ncreate_modeldata(model::Model, vectype::DataType=Array{Float64,1})\nModelData\nadd_arrays_data!\npush_arrays_data!\nallocate_variables!\n\ncheck_ready(model::Model, modeldata::AbstractModelData; throw_on_error=true)\ncheck_configuration(model::Model)\ninitialize_reactiondata!(model::Model, modeldata::AbstractModelData)\ndispatch_setup\ncreate_dispatch_methodlists\nReactionMethodDispatchList","category":"page"},{"location":"Solver API/#PALEOboxes.create_model_from_config-Tuple{AbstractString, AbstractString}","page":"Solver API","title":"PALEOboxes.create_model_from_config","text":"create_model_from_config(\n    config_file::AbstractString, configmodel::AbstractString;\n    modelpars::Dict = Dict()\n) -> model::Model\n\ncreate_model_from_config(\n    config_files,\n    configmodel::AbstractString;\n    modelpars::Dict = Dict()\n) -> model::Model\n\nConstruct model from a single YAML config_file, or from a collection of config_files,  which are read in order and concatenated before being parsed as yaml.\n\nOptional argument modelpars provides parameters that override those in <configmodel>: parameters: section.\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#PALEOboxes.create_modeldata","page":"Solver API","title":"PALEOboxes.create_modeldata","text":"create_modeldata(model::Model [, eltype] [; threadsafe]) -> modeldata::ModelData\n\nCreate a new ModelData struct for model variables of element type eltype.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.ModelData","page":"Solver API","title":"PALEOboxes.ModelData","text":"ModelData(model::Model; arrays_eltype::DataType=Float64, threadsafe::Bool=false, allocatenans::Bool=true)\n\nCreate a ModelData struct containing model data arrays.\n\nOne set of data arrays is created with eltype=arrays_eltype, accessed with arrays_idx=1\n\nAdditional sets of data arrays may be added by push_arrays_data!, eg in order to support automatic differentiation which requires Dual numbers as the array element type.\n\nFields\n\ncellranges_all::Vector{AbstractCellRange}: default cellranges covering all domains\ndispatchlists_all: default dispatchlists covering all domains\nsolver_view_all: optional untyped context field for use by external solvers.\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#PALEOboxes.add_arrays_data!","page":"Solver API","title":"PALEOboxes.add_arrays_data!","text":"add_arrays_data!(\n    model, modeldata, arrays_eltype::DataType, arrays_tagname::AbstractString;\n    [method_barrier=nothing] [, generated_dispatch=true] [, kwargs...])\n\nAdd a data array set to modeldata, allocate memory, and initialize reactiondata.\n\nElement type and tag name are set by arrays_eltype, arrays_tagname\n\nSee allocate_variables!(model::Model, modeldata::AbstractModelData, arrays_idx::Int) and  [initialize_reactiondata!] for keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.push_arrays_data!","page":"Solver API","title":"PALEOboxes.push_arrays_data!","text":"push_arrays_data!(modeldata, arrays_eltype::DataType, arrays_tagname::AbstractString)\n\nAdd an (unallocated) additional array set with element type arrays_eltype.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.allocate_variables!","page":"Solver API","title":"PALEOboxes.allocate_variables!","text":"allocate_variables!(\n    vars, modeldata, arrays_idx; \n    [, eltypemap::Dict{String, DataType}],\n    [, default_host_dependent_field_data=nothing],\n    [, allow_base_link=true],\n    [, use_base_vars=String[]])\n\nAllocate or link memory for VariableDomains vars in modeldata arrays arrays_idx\n\nElement type of allocated Arrays is determined by eltype(modeldata, arrays_idx) (the usual case, allowing use of AD types),  which can be overridden by Variable :datatype attribute if present (allowing Variables to ignore AD types). :datatype may be either a Julia DataType (eg Float64), or a string to be looked up in eltypemap.\n\nIf allow_base_link==true, and any of the following are true a link is made to the base array, instead of allocating:     - Variable element type matches modeldata base eltype (arraysidx=1)     - `usebasetransferjacobian=trueand Variable:transferjacobianattribute is set     - Variable full name is inusebase_vars`\n\nField data type is determined by Variable :field_data attribute, optionally this can take a default_host_dependent_field_data default for Variables with host_dependent(v)==true (these are Variables with no Target or no Property linked, intended to be external dependencies supplied by the solver).\n\n\n\n\n\nallocate_variables!(model, modeldata, arrays_idx; kwargs...)\n\nAllocate memory for Domain variables for every Domain in model.\n\nSee allocate_variables!(domain::Domain, modeldata::AbstractModelData, arrays_idx::Int).\n\n\n\n\n\nallocate_variables!(domain, modeldata, arrays_idx; [hostdep=false] [, kwargs...])\n\nAllocate memory for Domain Variables. \n\nIf hostdep=false, only internal Variables are allocated, allowing host-dependent Variables (usually state Variables and derivatives + any external dependencies) to be set to views on host-managed arrays.\n\nSee allocate_variables!(vars, modeldata::AbstractModelData, arrays_idx::Int).\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.check_ready-Tuple{PALEOboxes.Model, PALEOboxes.AbstractModelData}","page":"Solver API","title":"PALEOboxes.check_ready","text":"check_ready(model, modeldata; [throw_on_error=true] [, check_hostdep_varnames=true] [, expect_hostdep_varnames=[\"global.tforce\"]]) -> ready\n\nCheck all variable pointers set, and no unexpected host-dependent non-state Variables (ie unlinked Variables)\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#PALEOboxes.check_configuration-Tuple{PALEOboxes.Model}","page":"Solver API","title":"PALEOboxes.check_configuration","text":"Check configuration\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#PALEOboxes.initialize_reactiondata!-Tuple{PALEOboxes.Model, PALEOboxes.AbstractModelData}","page":"Solver API","title":"PALEOboxes.initialize_reactiondata!","text":"initialize_reactiondata!(model::Model, modeldata::AbstractModelData; kwargs...)\n\nProcesses VarList_...s from ReactionMethods and populates modeldata.sorted_methodsdata_... with sorted lists of ReactionMethods and corresponding Variable accessors.\n\nOptionally calls create_dispatch_methodlists(model, modeldata, modeldata.cellranges_all) to set modeldata.dispatchlists_all to default  ReactionMethodDispatchLists for entire model.\n\nKeyword arguments\n\narrays_indices=1:num_arrays(modeldata): modeldata arrays_idx to generate dispatch lists for\ncreate_dispatchlists_all=false: true to set modeldata.dispatchlists_all\ngenerated_dispatch=true: true to use autogenerated code for modeldata.dispatchlists_all (fast dispatch, slow compile)\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#PALEOboxes.dispatch_setup","page":"Solver API","title":"PALEOboxes.dispatch_setup","text":"dispatch_setup(model, attribute_name, modeldata, cellranges=modeldata.cellranges_all)\n\nCall setup methods, eg to initialize data arrays (including state variables).\n\nattribute_name defines the setup operation performed. dispatch_setup should be called in sequence with attribute_name = :\n\n:setup: initialise Reactions and set up any non-state Variables (eg model grid Variables) (applied to modeldata arrays_idx=1, values then copied to other arrays_idx)\n:norm_value: set state Variable values from :norm_value attribute in .yaml file, and initialise any Reaction state that requires this value (arrays_idx 1 only)\n:initial_value (optional): set state Variable values from :initial_value attribute in .yaml file (arrays_idx 1 only)\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.create_dispatch_methodlists","page":"Solver API","title":"PALEOboxes.create_dispatch_methodlists","text":"create_dispatch_methodlists(model::Model, modeldata::AbstractModelData, arrays_idx::Int, cellranges; kwargs) \n    -> (;list_initialize, list_do)\n\nCompile lists of initialize and do methods + corresponding cellrange for main loop do_deriv.\n\nSubset of methods and cellrange to operate on are generated from supplied cellranges.\n\nKeyword arguments\n\nverbose=false: true for additional log output\ngenerated_dispatch=true: true to create ReactionMethodDispatchLists (fast dispatch using generated code, slow compile time),  false to create ReactionMethodDispatchListNoGen (slow dynamic dispatch, fast compile time)\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.ReactionMethodDispatchList","page":"Solver API","title":"PALEOboxes.ReactionMethodDispatchList","text":"ReactionMethodDispatchList\n\nDefines a list of ReactionMethod with corresponding CellRange and views on Variable data (sub)arrays.\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#Attaching-numerical-solvers","page":"Solver API","title":"Attaching numerical solvers","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"High-level access to aggregated collections of Variables is provided by VariableAggregator and VariableAggregatorNamed (see Accessing model objects for low-level access).","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"VariableAggregator\nget_indices\ncopyto!(dest::VariableAggregator, src::AbstractVector; sof::Int=1)\ncopyto!(dest::AbstractVector, src::VariableAggregator; dof::Int=1)\n\nVariableAggregatorNamed","category":"page"},{"location":"Solver API/#PALEOboxes.VariableAggregator","page":"Solver API","title":"PALEOboxes.VariableAggregator","text":"VariableAggregator(vars, cellranges, modeldata, arrays_idx) -> VariableAggregator\n\nAggregate multiple VariableDomains into a flattened list (a contiguous Vector).\n\nCreates a VariableAggregator for collection of Variables vars, with indices from corresponding cellranges, for data arrays in modeldata with arrays_idx.\n\ncellranges may contain nothing entries to indicate whole Domain.\n\nThis is mostly useful for aggregating state Variables, derivatives, etc to implement an interface to a generic ODE/DAE etc solver.\n\nValues may be copied to and from a Vector using copyto!\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#PALEOboxes.get_indices","page":"Solver API","title":"PALEOboxes.get_indices","text":"get_indices(va::VariableAggregator, varnamefull::AbstractString; allow_not_found=false) -> indices::UnitRange{Int64}\n\nReturn indices in flattened Vector corresponding to Variable varnamefull\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#Base.copyto!-Tuple{PALEOboxes.VariableAggregator, AbstractVector{T} where T}","page":"Solver API","title":"Base.copyto!","text":"copyto!(dest::VariableAggregator, src::AbstractVector; sof=1) -> num_copied::Int\n\nSet aggregated Variables dest = (contiguous) Vector src.\n\nOptional sof sets first index in src to use.\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#Base.copyto!-Tuple{AbstractVector{T} where T, PALEOboxes.VariableAggregator}","page":"Solver API","title":"Base.copyto!","text":"copyto!(dest::AbstractVector, va::VariableAggregator; dof=1) -> num_copied::Int\n\nSet (contiguous) Vector dest = aggregated Variables src\n\nOptional dof sets first index in dest\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#PALEOboxes.VariableAggregatorNamed","page":"Solver API","title":"PALEOboxes.VariableAggregatorNamed","text":"VariableAggregatorNamed(modeldata, arrays_idx=1) -> VariableAggregatorNamed\nVariableAggregatorNamed(vars, modeldata, arrays_idx=1) -> VariableAggregatorNamed\nVariableAggregatorNamed(va::VariableAggregator; ignore_cellranges=false) -> VariableAggregatorNamed\n\nAggregate VariableDomains into nested NamedTuples, with Domain and Variable names as keys and data arrays (from get_data) as values.\n\nAny / characters in Variable names are replaced with __ (double underscore)\n\nThis provides direct access to Variables by name, and is mostly useful for testing or for small models.\n\nFields\n\nvars: nested NamedTuples (domainname, varname) of VariableDomains\nvalues: nested NamedTuples (domainname, varname) of data arrays.\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#Defining-CellRanges","page":"Solver API","title":"Defining CellRanges","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"AbstractCellRange\nCellRange\nCellRangeColumns\ncreate_default_cellrange","category":"page"},{"location":"Solver API/#PALEOboxes.AbstractCellRange","page":"Solver API","title":"PALEOboxes.AbstractCellRange","text":"AbstractCellRange\n\nDefines a range of cells within a Domain.\n\nFields\n\nAll implementations should define:\n\ndomain::Domain: the Domain covered by this cellrange.\noperatorID::Int: If operatorID==0, call all Reactions, otherwise only call those with matching operatorID (this enables operator splitting).\nindices: an iterable list of cell indices.\n\nAnd then may provide subtype-specific fields defining additional ranges of cells.\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#PALEOboxes.CellRange","page":"Solver API","title":"PALEOboxes.CellRange","text":"CellRange <: AbstractCellRange\n\nDefines a range of cells in a specified Domain as a linear list.\n\nFields\n\ndomain\noperatorID\nindices: may be any valid Julia indexing range thing eg 1:100, [1 2 3 4], etc\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#PALEOboxes.CellRangeColumns","page":"Solver API","title":"PALEOboxes.CellRangeColumns","text":"CellRangeColumns <: AbstractCellRange\n\nDefines a range of cells in a specified Domain, organised by columns.\n\nFields\n\ndomain\noperatorID\nindices: iterator through all cells in arbitrary order\ncolumns: iterator through columns: columns[n] returns a Pair icol=>cells where cells are ordered top to bottom\n\n\n\n\n\n","category":"type"},{"location":"Solver API/#PALEOboxes.create_default_cellrange","page":"Solver API","title":"PALEOboxes.create_default_cellrange","text":"create_default_cellrange(model::Model [; operatorID=0]) -> Vector{AbstractCellRange}\n\nCreate a Vector of CellRange instances covering the entire model.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes.Grids","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"create_default_cellrange\ncellrange_cartesiantile","category":"page"},{"location":"Solver API/#PALEOboxes.Grids.create_default_cellrange","page":"Solver API","title":"PALEOboxes.Grids.create_default_cellrange","text":"create_default_cellrange(domain, grid, [; operatorID=0]) -> CellRange\n\nCreate a CellRange for entire domain and supplied operatorID\n\n\n\n\n\ncreate_default_cellrange(domain, grid::Nothing [; operatorID=0]) -> CellRange\n\nCreate a CellRange for entire domain. Fallback for a domain with no grid\n\n\n\n\n\ncreate_default_cellrange(domain, grid::UnstructuredVectorGrid [; operatorID=0]) -> CellRange\n\nCreate a CellRange for entire domain - use linear index.\n\n\n\n\n\ncreate_default_cellrange(domain, grid::UnstructuredColumnGrid [; operatorID=0]) -> CellRangeColumns\n\nCreate a CellRange for entire domain. Return a PB.CellRangeColumns with iterators for columns and cells.\n\n\n\n\n\ncreate_default_cellrange(domain, grid::Union{CartesianLinearGrid, CartesianArrayGrid} [; operatorID=0]) -> CellRangeColumns\n\nCreate a CellRange for entire domain. Return a PB.CellRangeColumns provided by cellrange_cartesiantile\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.Grids.cellrange_cartesiantile","page":"Solver API","title":"PALEOboxes.Grids.cellrange_cartesiantile","text":"cellrange_cartesiantile\n\nCreate a range of cells within a region of CartesianLinearGrid specified by rangestuple in a specified PB.Domain\n\nrangestuple is a tuple of Cartesian index ranges eg (1:9, :, :) for a 3D grid.\n\n\n\n\n\n3D case return a CellRangeColumns\n\n\n\n\n\nreturn partitioning of a 3D Domain into n tiles\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#Main-loop","page":"Solver API","title":"Main loop","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"do_deriv\ndispatch_methodlist","category":"page"},{"location":"Solver API/#PALEOboxes.do_deriv","page":"Solver API","title":"PALEOboxes.do_deriv","text":"do_deriv(dispatchlists, deltat::Float64=0.0)\n\nWrapper function to calculate entire derivative (initialize and do methods) in one call. dispatchlists is from create_dispatch_methodlists.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.dispatch_methodlist","page":"Solver API","title":"PALEOboxes.dispatch_methodlist","text":"dispatch_methodlist(dl::ReactionMethodDispatchList, deltat::Float64=0.0)\n\nDispatch to a list of methods.\n\nImplementation\n\nAs an optimisation, uses @generated for Type stability and to avoid dynamic dispatch, instead of iterating over lists.\n\nReactionMethodDispatchList fields are Tuples hence are fully Typed, the @generated function emits unrolled code with a function call for each Tuple element. \n\n\n\n\n\n","category":"function"},{"location":"Solver API/#Diagnostics","page":"Solver API","title":"Diagnostics","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"show_methods_setup\nshow_methods_initialize\nshow_methods_do\nshow_variables\nshow_links\nshow_parameters","category":"page"},{"location":"Solver API/#PALEOboxes.show_methods_setup","page":"Solver API","title":"PALEOboxes.show_methods_setup","text":"show_methods_setup(model::Model)\n\nDisplay ordered list of Reaction setup methods (registered by add_method_setup!, called by dispatch_setup)\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.show_methods_initialize","page":"Solver API","title":"PALEOboxes.show_methods_initialize","text":"show_methods_initialize(model::Model)\n\nDisplay ordered list of Reaction initialize methods (registered by add_method_initialize!, called by do_deriv at start of each model timestep).\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.show_methods_do","page":"Solver API","title":"PALEOboxes.show_methods_do","text":"show_methods_do(model::Model)\n\nDisplay ordered list of Reaction do methods (registered by add_method_do!, called by do_deriv for each model timestep).\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.show_variables","page":"Solver API","title":"PALEOboxes.show_variables","text":"show_variables(obj, ...) -> Table\n\nShow all Variables attached to PALEO object obj\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.show_links","page":"Solver API","title":"PALEOboxes.show_links","text":"show_links(vardom::VariableDomain)\nshow_links(model::Model, varnamefull::AbstractString)\nshow_links(io::IO, vardom::VariableDomain)\nshow_links(io::IO, model::Model, varnamefull::AbstractString)\n\nDisplay all VariableReactions linked to this VariableDomain\n\nvarnamefull should be of form \"<domain name>.<variable name>\"\n\nLinked variables are shown as \"<domain name>.<reaction name>.<method name>.<local name>\"\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.show_parameters","page":"Solver API","title":"PALEOboxes.show_parameters","text":"show_parameters(model) -> DataFrame\n\nGet parameters for all reactions in model.\n\nExamples:\n\nShow all model parameters using VS Code table viewer:\n\njulia> vscodedisplay(PB.show_parameters(run.model))\n\nWrite out all model parameters as csv for import to a spreadsheet:\n\njulia> CSV.write(\"pars.csv\", PB.show_parameters(run.model))\n\n\n\n\n\nshow_parameters(react::AbstractReaction) -> DataFrame\nshow_parameters(classname::AbstractString) -> DataFrame\n\nlist all parameters for a Reaction react instance or classname\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#Accessing-model-objects","page":"Solver API","title":"Accessing model objects","text":"","category":"section"},{"location":"Solver API/#[Model](@ref)","page":"Solver API","title":"Model","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"get_domain\nget_reaction(model::Model, domainname, reactionname)\nset_parameter_value!\nget_parameter_value\nset_variable_attribute!\nget_variable_attribute\n","category":"page"},{"location":"Solver API/#PALEOboxes.get_domain","page":"Solver API","title":"PALEOboxes.get_domain","text":"get_domain(model::Model, name::AbstractString; allow_not_found=true) -> Domain or nothing\nget_domain(model::Model, domainid) -> Domain\n\nGet Domain by name (may be nothing if name not matched) or domainid (range 1:num_domains).\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_reaction-Tuple{PALEOboxes.Model, Any, Any}","page":"Solver API","title":"PALEOboxes.get_reaction","text":"get_reaction(model::Model, domainname, reactionname; allow_not_found=false) -> Reaction or nothing\n\nGet Reaction by domainname and reaction name\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#PALEOboxes.set_parameter_value!","page":"Solver API","title":"PALEOboxes.set_parameter_value!","text":"set_parameter_value!(model::Model, domainname, reactionname, parname, value)\n\nConvenience function to set Parameter value.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_parameter_value","page":"Solver API","title":"PALEOboxes.get_parameter_value","text":"get_parameter_value(model::Model, domainname, reactionname, parname) -> value\n\nConvenience function to get Parameter value.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.set_variable_attribute!","page":"Solver API","title":"PALEOboxes.set_variable_attribute!","text":"set_variable_attribute!(model::Model, varnamefull, attributename::Symbol, value)\n\nSet varnamefull (of form <domain name>.<var name>) attributename to value.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_variable_attribute","page":"Solver API","title":"PALEOboxes.get_variable_attribute","text":"get_variable_attribute(model::Model, varnamefull, attributename::Symbol, missing_value=missing) -> attributevalue\n\nGet varnamefull (of form <domain name>.<var name>) attributename.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#[Domain](@ref)s","page":"Solver API","title":"Domains","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"get_variable\nget_variables\nget_host_variables\nget_unallocated_variables\nget_reaction(domain::Domain, reactname::String)","category":"page"},{"location":"Solver API/#PALEOboxes.get_variable","page":"Solver API","title":"PALEOboxes.get_variable","text":"get_variable(obj, varname, ...) -> variable\n\nGet variable <: VariableBase by name from PALEO object\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_variables","page":"Solver API","title":"PALEOboxes.get_variables","text":"get_variables(varlist::AbstractVarList) -> Vector{VariableReaction}\n\nReturn VariableReaction in varlist as a flat Vector.\n\n\n\n\n\nget_variables(domain; hostdep=nothing, vfunction=VF_Undefined) -> Vector{VariableDomain}\n\nGet domain variables, optionally filtering for subsets based on hostdep and :vfunction attribute\n\n\n\n\n\nget_variables(domain, filter) -> Vector{VariableDomain}\n\nGet subset of domain variables where filter(var) == true.\n\n\n\n\n\nget_variables(method::AbstractReactionMethod; filterfn = v -> true) -> Vector{VariableReaction}\n\nGet VariableReactions from method.varlists as a flat Vector, optionally restricting to those that match filterfn\n\n\n\n\n\nget_variables(reaction, localname) -> Vector{VariableReaction}\nget_variables(reaction; [filterfn=v->true]) -> Vector{VariableReaction}\n\nGet matching Variables from all ReactionMethods.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_host_variables","page":"Solver API","title":"PALEOboxes.get_host_variables","text":"get_host_variables(domain, vfunction; [match_deriv_suffix=\"\"] [, operatorID=0] [, exclude_var_nameroots=[]] [, verbose=false]) \n    -> (host_vars, host_deriv_vars)\n\nGet state Variables with VariableFunction vfunction, and optionally  corresponding time derivative with VariableFunction VF_Deriv and name matching hostvarname*<match_deriv_suffix`>.\n\nOptionally filter by operatorID, omit Variables with name matching exclude_var_nameroots.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_unallocated_variables","page":"Solver API","title":"PALEOboxes.get_unallocated_variables","text":"get_unallocated_variables(domain, modeldata, arrays_idx::Int) -> Vector{VariableDomain}\n\nReturn any unallocated variables (host-dependent variables which have no data pointer set)\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_reaction-Tuple{PALEOboxes.Domain, String}","page":"Solver API","title":"PALEOboxes.get_reaction","text":"get_reaction(domain, reactname; allow_not_found) -> Reaction or nothing\n\nGet a reaction by name.\n\n\n\n\n\n","category":"method"},{"location":"Solver API/#VariableDomain","page":"Solver API","title":"VariableDomain","text":"","category":"section"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"Low-level access to individual Variables.","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Solver API/","page":"Solver API","title":"Solver API","text":"set_data!\nget_data\nget_data_output","category":"page"},{"location":"Solver API/#PALEOboxes.set_data!","page":"Solver API","title":"PALEOboxes.set_data!","text":"set_data!(var::VariableDomain, modeldata, arrays_idx::Int, data)\n\nSet VariableDomain to a Field containing data.\n\nCalls wrap_field to create a new Field.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_data","page":"Solver API","title":"PALEOboxes.get_data","text":"get_data(var::VariableDomain, modeldata::AbstractModelData, arrays_idx::Int=1) -> field.values\nget_data(var::VariableDomain, domaindata::AbstractDomainData) -> field.values\n\nGet Variable var data array from Field.values\n\n\n\n\n\nget_data(va::VariableAggregator) -> Vector\n\nAllocate Vector and set to values of aggregated Variables va.\n\n\n\n\n\n","category":"function"},{"location":"Solver API/#PALEOboxes.get_data_output","page":"Solver API","title":"PALEOboxes.get_data_output","text":"get_data(var::VariableDomain, modeldata::AbstractModelData, arrays_idx::Int) -> get_values_output(field.values)\nget_data(var::VariableDomain, domaindata::AbstractDomainData) -> get_values_output(field.values)\n\nGet a sanitized version of Variable var data array for storing as output from [get_values_output]@ref)(Field.values)\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Reaction-API","page":"Reaction API","title":"Reaction API","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"API calls used by AbstractReaction implementations.","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"Implementations should create a subclass of AbstractReaction containing a ReactionBase and Parameters, optionally provide a create_reaction, and implement callbacks to define VariableReactions and register ReactionMethods.","category":"page"},{"location":"Reaction API/#Reaction-struct","page":"Reaction API","title":"Reaction struct","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"CurrentModule = PALEOboxes","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"AbstractReaction\nReactionBase","category":"page"},{"location":"Reaction API/#PALEOboxes.AbstractReaction","page":"Reaction API","title":"PALEOboxes.AbstractReaction","text":"AbstractReaction\n\nAbstract base Type for Reactions.\n\nImplementation\n\nDerived types should include a field base::ReactionBase, and usually a ParametersTuple, eg\n\nBase.@kwdef mutable struct ReactionHello{P} <: PB.AbstractReaction\n    base::PB.ReactionBase\n\n    pars::P = PB.ParametersTuple(\n        PB.ParDouble(\"my_par\", 42.0, units=\"yr\", \n            description=\"an example of a Float64-valued scalar parameter called 'my_par'\"),\n    )\n\n    some_additional_field::Float64   # additional fields to eg cache data read from disk etc\nend\n\nDerived types should implement register_methods!, and may optionally implement create_reaction,  set_model_geometry, check_configuration, register_dynamic_methods!.\n\nMethods should be registered using add_method_setup!, add_method_initialize!, add_method_do!.\n\nAny parameters not included in pars should be added explicitly with add_par (this is rarely needed).\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.ReactionBase","page":"Reaction API","title":"PALEOboxes.ReactionBase","text":"ReactionBase\n\nBase Type for a biogeochemical Reaction.\n\nImplementation\n\nInclude as field base in types derived from AbstractReaction\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#Parameters","page":"Reaction API","title":"Parameters","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"AbstractParameter\nParameter\nVecParameter\nVecVecParameter\nParametersTuple\nadd_par\nsetvalue!","category":"page"},{"location":"Reaction API/#PALEOboxes.AbstractParameter","page":"Reaction API","title":"PALEOboxes.AbstractParameter","text":"AbstractParameter\n\nBase Type for Parameters\n\nSee also: Parameter, VecParameter, VecVecParameter\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.Parameter","page":"Reaction API","title":"PALEOboxes.Parameter","text":"Parameter{T, ParseFromString}\n\nA reaction parameter of type T.\n\nCreate using short names ParDouble, ParInt, ParBool, ParString.\n\nRead value as <par>[], set with setvalue!.\n\nParameters with external=true may be set from the Model-level Parameters list, if name is present in that list.\n\nParseFromString should usually be Nothing: a value of Type T is then required when calling setvalue!. If ParseFromString is not Nothing, then setvalue! will accept an AbstractString and call Base.parse(ParseFromString, strvalue). This allows eg an enum-valued Parameter to be defined by Parameter{EnumType, EnumType} and implementing parse(EnumType, rawvalue::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VecParameter","page":"Reaction API","title":"PALEOboxes.VecParameter","text":"VecParameter{T, ParseFromString}\n\nA reaction parameter of type Vector{T}.\n\nCreate using short names ParDoubleVec, ParStringVec.\n\nRead values as <par>[i], access raw Vector{T} as <par>.v.\n\nSet with setvalue!, in config file use standard yaml syntax for a vector eg [1, 2, 3]\n\nSee Parameter for additional documentation.\n\nImplementation\n\nImplements part of the AbstractVector interface, sufficient to access elements as <par>[i], and to support iteration eg for v in <par>;  ...; end.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VecVecParameter","page":"Reaction API","title":"PALEOboxes.VecVecParameter","text":"VecVecParameter{T, ParseFromString}\n\nA reaction parameter of type Vector{Vector{T}}.\n\nCreate using short names ParDoubleVecVec.\n\nRead values as <par>.v::Vector{Vector{T}}.\n\nSet using standard yaml syntax for a vector of vectors eg [[1, 2, 3], [4, 5, 6]]\n\nSee Parameter for additional documentation.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.ParametersTuple","page":"Reaction API","title":"PALEOboxes.ParametersTuple","text":"ParametersTuple(parameters::AbstractParameter...) -> NamedTuple\nParametersTuple(parameters) -> NamedTuple\n\nCreate a NamedTuple of Parameters.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.add_par","page":"Reaction API","title":"PALEOboxes.add_par","text":"add_par(reaction::AbstractReaction, par::AbstractParameter)\nadd_par(reaction::AbstractReaction, objectwithpars)\n\nAdd a single parameter or parameters from fields of objectwithpars to a new Reaction.\n\nNot usually needed: Parameters in pars::ParametersTuplewill be added automatically, only needed if there are additional Parameters that are not members ofpars`.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.setvalue!","page":"Reaction API","title":"PALEOboxes.setvalue!","text":"setvalue!(par::Parameter, value)\n\nSet Parameter to value.\n\nOptionally (if Parameter has Type parameter ParseFromString != Nothing) parse value from a String.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Registering-Reactions-with-the-PALEOboxes-framework","page":"Reaction API","title":"Registering Reactions with the PALEOboxes framework","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"All subtypes of AbstractReaction that are present in loaded modules are available to the PALEO framework.  Available Reactions can be listed with find_reaction and find_all_reactions.  The default create_reaction is called to create Reactions when the model is created (this method can be overridden if needed).","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"create_reaction(ReactionType::Type{<:AbstractReaction}, base::ReactionBase)\n\nfind_reaction\nfind_all_reactions","category":"page"},{"location":"Reaction API/#PALEOboxes.create_reaction-Tuple{Type{var\"#s6\"} where var\"#s6\"<:PALEOboxes.AbstractReaction, PALEOboxes.ReactionBase}","page":"Reaction API","title":"PALEOboxes.create_reaction","text":"create_reaction(ReactionType::Type{<:AbstractReaction}, base::ReactionBase) -> reaction::AbstractReaction\n\nCreate a ReactionType and set base field.\n\nDefault implementation may be overridden to eg set additional fields\n\n\n\n\n\n","category":"method"},{"location":"Reaction API/#PALEOboxes.find_reaction","page":"Reaction API","title":"PALEOboxes.find_reaction","text":"find_reaction(class::AbstractString) -> ReactionType\n\nLook up \"class\" in list of Reactions from find_all_reactions, and return  fully-qualified Reaction Type (including module prefixes).\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.find_all_reactions","page":"Reaction API","title":"PALEOboxes.find_all_reactions","text":"find_all_reactions() -> Dict{String, Type}\n\nUse InteractiveUtils.subtypes(AbstractReaction) to find all currently loaded subtypes off AbstractReaction, and create a Dict with last part of the name of the Type as key (ie without the module prefix) and Type as value.\n\nAny Types that generate non-unique keys (eg Module1.MyReactionType and Module2.MyReactionType) will generate a warning, and no entry will be added to the Dict (so if this Reaction is present in a config file, it will not be found and will error).\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Defining-Domain-Grids-and-array-sizes","page":"Reaction API","title":"Defining Domain Grids and array sizes","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"set_model_geometry\nset_data_dimension!","category":"page"},{"location":"Reaction API/#PALEOboxes.set_model_geometry","page":"Reaction API","title":"PALEOboxes.set_model_geometry","text":"set_model_geometry(reaction, model)\n\nOptional: define Domain grid, data_dims.\n\nOne Reaction per Domain may create a grid (an AbstractMesh subtype) and set the domain.grid field.\n\nMultiple Reactions per domain may call set_data_dimension! to define (different) named data dimensions (eg wavelength grids).\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.set_data_dimension!","page":"Reaction API","title":"PALEOboxes.set_data_dimension!","text":"set_data_dimension!(domain::Domain, dim::NamedDimension; allow_exists=false)\n\nDefine a Domain data dimension as a NamedDimension\n\nVariables may then specify data dimensions as a list of names using the :data_dims Variable Attribute.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Creating-and-registering-Reaction-methods","page":"Reaction API","title":"Creating and registering Reaction methods","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"All Reactions should implement register_methods!, and may optionally implement register_dynamic_methods!.","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"register_methods!\nregister_dynamic_methods!","category":"page"},{"location":"Reaction API/#PALEOboxes.register_methods!","page":"Reaction API","title":"PALEOboxes.register_methods!","text":"register_methods!(reaction)\nregister_methods!(reaction, model)\n\nAdd ReactionMethods, using add_method_setup!, add_method_initialize! add_method_do!. See also register_dynamic_methods!.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.register_dynamic_methods!","page":"Reaction API","title":"PALEOboxes.register_dynamic_methods!","text":"register_dynamic_methods!(reaction)\nregister_dynamic_methods!(reaction, model)\n\nOptional: called after first variable link pass, to add ReactionMethods that depend on Variables generated by other Reactions (see register_methods!).\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"These methods should then define one or more ReactionMethods, which requires:","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"Defining collections of VariableReactions (see Defining VariableReactions,  Defining collections of VariableReactions).\nImplementing a function to iterate over model cells and calculate the required fluxes etc (see Implementing method functions)\nAdding methods (see Adding ReactionMethods).","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"In addition it is possible to add Predefined ReactionMethods for some common operations (Variable initialisation, calculating totals, etc).","category":"page"},{"location":"Reaction API/#Defining-VariableReactions","page":"Reaction API","title":"Defining VariableReactions","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"VariableReaction\nparse_variablereaction_namestr\nset_attribute!","category":"page"},{"location":"Reaction API/#PALEOboxes.VariableReaction","page":"Reaction API","title":"PALEOboxes.VariableReaction","text":"VariableReaction(VT, localname => link_namestr, units, description; attributes=Tuple()) -> VariableReaction{VT}\nVariableReaction(VT, linklocal_namestr, units, description; attributes=Tuple()) -> VariableReaction{VT}    \n\nVarProp, VarPropScalar, VarPropStateIndep, VarPropScalarStateIndep -> VariableReaction{VT_ReactProperty}\nVarDep, VarDepColumn, VarDepScalar, VarDepStateIndep, VarDepColumnStateIndep, VarDepScalarStateIndep -> VariableReaction{VT_ReactDependency}\nVarTarget, VarTargetScalar -> VariableReaction{VT_ReactTarget}\nVarContrib, VarContribColumn, VarContribScalar -> VariableReaction{VT_ReactContributor}\nVarStateExplicit, VarStateExplicitScalar -> VariableReaction{VT_ReactDependency}\nVarDeriv, VarDerivScalar -> VariableReaction{VT_ReactContributor}\nVarState, VarStateScalar -> VariableReaction{VT_ReactDependency}\nVarConstraint, VarConstraintScalar -> VariableReaction{VT_ReactDependency}\n\n[deprecated] VariableReaction(VT, localname, units, description; link_namestr, attributes=Tuple()) -> VariableReaction{VT}\n\nReaction view on a model variable.\n\nReactions define AbstractVarLists of VariableReactions when creating a ReactionMethod.  Within a ReactionMethod, a VariableReaction is referred to by localname. When the model is initialised,  VariableDomain variables are created that link together VariableReactions with the same link_namestr, and data Arrays are allocated. views on the VariableDomain data Arrays are then passed to the ReactionMethod function at each timestep.\n\nSubtypes\n\nThe Type parameter VT is one of VT_ReactProperty, VT_ReactDependency, VT_ReactContributor, VT_ReactTarget, where  short names are defined for convenience:\n\nconst VarPropT        = VariableReaction{VT_ReactProperty}\nconst VarDepT         = VariableReaction{VT_ReactDependency}\nconst VarTargetT      = VariableReaction{VT_ReactTarget}\nconst VarContribT     = VariableReaction{VT_ReactContributor}\n\nThere are two pairings of VariableReactions with VariableDomains:\n\nReaction Property and Dependency Variables, linked to a VariableDomPropDep. These are used to represent   a quantity calculated in one Reaction that is then used by other Reactions.\nReaction Target and Contributor Variables, linked to a VariableDomContribTarget. These are used to represent   a flux-like quantity, with one Reaction definining the Target and multiple Reactions adding contributions.\n\nVariable Attributes and constructor convenience functions\n\nVariable attributes are used to define Variable :space AbstractSpace (scalar, per-cell, etc) and data content :field_data AbstractData,  and to label state Variables for use by numerical solvers.  Additional attributes can be specified to provide model-specific information, with defaults defined in the .jl code that can then be overridden in the .yaml configuration file, see StandardAttributes\n\nVariableReaction is usually not called directly, instead convenience functions are defined that provide commonly-used combinations of VT and attributes:\n\nshort name VT attributes     \n  :space :field_data :vfunction :initialize_to_zero :datatype :is_constant\n       \nVarProp VT_ReactProperty CellSpace ScalarData VF_Undefined - - false\nVarPropScalar VT_ReactProperty ScalarSpace ScalarData VF_Undefined - - false\nVarPropStateIndep VT_ReactProperty CellSpace ScalarData VF_Undefined - Float64 true\nVarPropScalarStateIndep VT_ReactProperty ScalarSpace ScalarData VF_Undefined - Float64 true\n       \nVarDep VT_ReactDependency CellSpace ScalarData VF_Undefined - - false\nVarDepColumn VT_ReactDependency ColumnSpace ScalarData VF_Undefined - - false\nVarDepScalar VT_ReactDependency ScalarSpace ScalarData VF_Undefined - - false\nVarDepStateIndep VT_ReactDependency CellSpace ScalarData VF_Undefined - Float64 true\nVarDepColumnStateIndep VT_ReactDependency ColumnSpace ScalarData VF_Undefined - Float64 true\nVarDepScalarStateIndep VT_ReactDependency ScalarSpace ScalarData VF_Undefined - Float64 true\n       \nVarTarget VT_ReactTarget CellSpace ScalarData VF_Undefined true - false\nVarTargetScalar VT_ReactTarget ScalarSpace ScalarData VF_Undefined true - false\n       \nVarContrib VT_ReactContributor CellSpace ScalarData VF_Undefined - - false\nVarContribColumn VT_ReactContributor ColumnSpace ScalarData VF_Undefined - - false\nVarContribScalar VT_ReactContributor ScalarSpace ScalarData VF_Undefined - - false\n       \nVarStateExplicit VT_ReactDependency CellSpace ScalarData VF_StateExplicit - - false\nVarStateExplicitScalar VT_ReactDependency ScalarSpace ScalarData VF_StateExplicit - - false\nVarDeriv VT_ReactContributor CellSpace ScalarData VF_Deriv true - false\nVarDerivScalar VT_ReactContributor ScalarSpace ScalarData VF_Deriv true - false\n       \nVarState VT_ReactDependency CellSpace ScalarData VF_State - - false\nVarStateScalar VT_ReactDependency ScalarSpace ScalarData VF_State - - false\nVarConstraint VT_ReactContributor CellSpace ScalarData VF_Constraint true - false\nVarConstraintScalar VT_ReactContributor ScalarSpace ScalarData VF_Constraint true - false\n\nThis illustrates some general principles for the use of attributes:\n\nAll Variables must define:\nthe :space Attribute (a subtype of AbstractSpace) to specify whether they are Domain scalars, per-cell quantities, etc.\nthe :field_data Attribute (a subtype of AbstractData) to specify the quantity they represent. This defaults to  ScalarData to represent a scalar value. To eg represent a single isotope the :field_data attribute should be set to IsotopeLinear.\nThe :vfunction attribute is used to label state Variables and corresponding time derivatives, for access by a numerical solver.\nAn ODE-like combination of a state variable and time derivative are defined by a paired VarStateExplicit and VarDeriv. Note that that these are just VarDep and VarContrib with the :vfunction attribute set, and that there is no VarProp and VarTarget defined in the model (these are effectively provided by the numerical solver). The pairing is defined by the naming convention of varname and varname_sms.\nAn algebraic constraint (for a DAE) is defined by a VarState and VarConstraint. Note that that these are just VarDep and VarContrib with the :vfunction attribute set, and that there is no VarProp and VarTarget defined in the model (these are effectively provided by the numerical solver). These variables are not paired.\nThe :initialize_to_zero attribute is set for Target variables, this is than used (by the ReactionMethod created by add_method_initialize_zero_vars_default!) to identify variables that should be initialised to zero at the start of each timestep. This attribute is also set for Contributor variables VarDeriv and VarConstraint (as there is no corresponding Target variable in the model).\nThe :datatype attribute is used to provide a concrete datatype and exclude from automatic differentiation (TODO document this usage)\nThe :is_constant attribute is used to identify constant Property Variables (not modified after initialisation).\n\nSpecifying links\n\nlocalname identifies the VariableReaction within the Reaction, and can be used to set variable_attributes: and variable_links: in the .yaml configuration file.\n\nlinkreq_domain.linkreq_subdomain.linkreq_name defines the Domain, Subdomain and name for run-time linking to VariableDomain variables. \n\nArguments\n\nVT::VariableType:  one of VT_ReactProperty, VT_ReactDependency, VT_ReactContributor, VT_ReactTarget\nlocalname::AbstractString: Reaction-local Variable name\nlink_namestr::AbstractString: <linkreq_domain>.[linkreq_subdomain.]linkreq_name. Parsed by parse_variablereaction_namestr to define the requested linking to Domain Variable.\nlinklocal_namestr::AbstractString:  <linkreq_domain>.[linkreq_subdomain.]localname. Convenience form to define both localname and requested linking to Domain Variable, for the common case where linkreq_name == localname.\nunits::AbstractString: units (\"\" if not applicable)\ndescription::AbstractString: text describing the variable\n\nKeywords\n\nattributes::Tuple(:attrb1name=>attrb1value, :attrb2name=>attrb2value, ...):  variable attributes, see StandardAttributes, set_attribute!, get_attribute\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.parse_variablereaction_namestr","page":"Reaction API","title":"PALEOboxes.parse_variablereaction_namestr","text":"parse_variablereaction_namestr(linkstr) \n    -> (linkreq_domain, linkreq_subdomain, linkreq_name, link_optional)\n\nParse a linkstr into component parts.\n\nlinkstr is of format: [(][<linkreq_domain>.][<linkreq_subdomain>.]<linkreq_name>[)]\n\nOptional brackets ( ... ) set link_optional=true\nlinkreq_name may contain %reaction% which will later be substituted with <Reaction name>/\n\nExamples:\n\njulia> PALEOboxes.parse_variablereaction_namestr(\"foo\")  # Common case eg for a property that should be public\n(\"\", \"\", \"foo\", false)\n\njulia> PALEOboxes.parse_variablereaction_namestr(\"%reaction%foo\")  # Reaction-private by default\n(\"\", \"\", \"%reaction%foo\", false)\n\njulia> PALEOboxes.parse_variablereaction_namestr(\"ocean.foo\")  # Request link to variable of same name in ocean Domain\n(\"ocean\", \"\", \"foo\", false)\n\njulia> PALEOboxes.parse_variablereaction_namestr(\"(ocean.oceansurface.goo)\") # Full syntax\n(\"ocean\", \"oceansurface\", \"goo\", true)\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.set_attribute!","page":"Reaction API","title":"PALEOboxes.set_attribute!","text":"set_attribute!(var::VariableBase, name::Symbol, value, allow_create=false) -> var\n\nSet Variable attribute.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Defining-collections-of-VariableReactions","page":"Reaction API","title":"Defining collections of VariableReactions","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"AbstractVarList\nVarList_single\nVarList_namedtuple\nVarList_tuple\nVarList_vector\nVarList_vvector\nVarList_nothing\nVarList_tuple_nothing","category":"page"},{"location":"Reaction API/#PALEOboxes.AbstractVarList","page":"Reaction API","title":"PALEOboxes.AbstractVarList","text":"AbstractVarList\n\nVariables required by a ReactionMethod methodfn are specified by  a Tuple of VarList_xxx <: AbstractVarList, each containing a collection of VariableReaction.\n\nThese are then converted (by the create_accessors method) to a corresponding Tuple of collections of views on Domain data arrays , which are then be passed to the ReactionMethod methodfn.\n\nImplementation\n\nSubtypes of AbstractVarList should implement:\n\na constructor that takes a collection of VariableReactions\ncreate_accessors, returning the views on Domain data arrays in a subtype-specific collection.\nget_variables, returning the collection of VariableReactions (as a flat list).\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_single","page":"Reaction API","title":"PALEOboxes.VarList_single","text":"VarList_single(var; components=false) -> VarList_single\n\nCreate a VarList_single describing a single VariableReaction, create_accessors will then return a single accessor.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_namedtuple","page":"Reaction API","title":"PALEOboxes.VarList_namedtuple","text":"VarList_namedtuple(varcollection; components=false) -> VarList_namedtuple\n\nCreate a VarList_namedtuple describing a collection of VariableReactions, create_accessors will then return a NamedTuple with field names = VariableReaction.localname and field values = corresponding data arrays.\n\nIf components = true, each NamedTuple field will be a Vector of data array components.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_tuple","page":"Reaction API","title":"PALEOboxes.VarList_tuple","text":"VarList_tuple(varcollection; components=false) -> VarList_tuple\n\nCreate a VarList_tuple describing a collection of VariableReactions, create_accessors will then return a Tuple of data arrays.\n\nIf components = true, each Tuple field will be a Vector of data array components.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_vector","page":"Reaction API","title":"PALEOboxes.VarList_vector","text":"VarList_vector(varcollection; components=false, forceview=false) -> VarList_vector\n\nCreate a VarList_vector describing a collection of VariableReactions, create_accessors will then return a Vector of data arrays.\n\nIf components = true, each Vector element will be a Vector of data array components.\n\nIf forceview = true, each accessor will be a 1-D view to help type stability, even if this is redundant (ie no view required, v::Vector -> view(v, 1:length(v)))\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_vvector","page":"Reaction API","title":"PALEOboxes.VarList_vvector","text":"VarList_vvector(Vector{Vector{VariableReaction}}::vars; components=false) -> VarList_vvector\n\nCreate a VarList_vvector describing a Vector of Vectors of VariableReactions, create_accessors will then return a Vector of Vectors of data arrays.\n\nIf components = true, each Vector of Vectors element will be a Vector of data array components.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_nothing","page":"Reaction API","title":"PALEOboxes.VarList_nothing","text":"VarList_nothing() -> VarList_nothing\n\nCreate a placeholder for a missing/unavailable VariableReaction. create_accessors will then return nothing.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.VarList_tuple_nothing","page":"Reaction API","title":"PALEOboxes.VarList_tuple_nothing","text":"VarList_tuple_nothing(nvar) -> VarList_tuple_nothing\n\nCreate a placeholder for nvar missing/unavailable VariableReactions. create_accessors will then return an NTuple{nvar, Nothing}.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#Implementing-method-functions","page":"Reaction API","title":"Implementing method functions","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"Reaction method functions should iterate over the cells in the Domain supplied by cellrange argument and calculate appropriate biogeochemical fluxes etc (which may include the model time derivative and any intermediate or diagnostic output).","category":"page"},{"location":"Reaction API/#Iterating-over-cells","page":"Reaction API","title":"Iterating over cells","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"The simplest case is a method function that iterates over individual cells, with skeleton form:","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"function do_something_cellwise(m::PB.AbstractReactionMethod, pars, (vars, ), cellrange::PB.AbstractCellRange, deltat)\n\n    @inbounds for i in cellrange.indices\n        vars.A[i]  = something*vars.B[i]*vars.C[i]  # in general A is some function of B, C, etc\n        # etc\n    end\n\n    return nothing\nend","category":"page"},{"location":"Reaction API/#Iterating-over-cells-in-columns","page":"Reaction API","title":"Iterating over cells in columns","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"If necessary (eg to calculate vertical transport), provided the model grid and cellrange allow, it is possible to iterate over columns and then cells within columns (in order from top to bottom):","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"function do_something_columnwise(m::PB.AbstractReactionMethod, pars, (vars, ), cellrange::PB.AbstractCellRange, deltat)\n\n    @inbounds for (icol, colindices) in cellrange.columns\n        accum = zero(vars.A[first(colindices)]) # accumulator of appropriate type\n        for i in colindices  # order is top to bottom\n            accum += vars.A[i]\n            vars.C[i] = accum  # C = sum of A in cells above                 \n            # etc\n        end\n\n        vars.floor_C[icol] = vars.C[last(colindices)] # assumes model has a floor domain with one floor cell per column in the interior domain\n    end\n\n    return nothing\nend","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"Iteration from bottom to top within a column can be implemented using Iterators.reverse, eg","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"function do_something_columnwise(m::PB.AbstractReactionMethod, pars, (vars, ), cellrange::PB.AbstractCellRange, deltat)\n    @inbounds for (icol, colindices) in cellrange.columns\n        colreverse = Iterators.reverse(colindices)\n        for i in colreverse  # order is bottom to top\n            # etc\n        end\n    end\n\n    return nothing\nend","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"note: Note\nThe method function shouldn't make any assumptions about colindices other than that it is a list of indices ordered from top to bottom in a column.  Depending on the grid in use, the indices may not be contiguous, and may not be integers.","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"note: Note\nThe example above made the additional assumption that a floor domain had been defined (containing Variable floor_C) with one floor cell per column. This is determined by the model configuration, and is not true in general.","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"In rare cases where it is necessary to operate on a Vector representing a quantity for the whole column (rather than just iterate through it), this can be implemented using view, eg","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"function do_something_columnwise(m::PB.AbstractReactionMethod, pars, (vars, ), cellrange::PB.AbstractCellRange, deltat)\n    @inbounds for (icol, colindices) in cellrange.columns\n        A_col = view(vars.A, colindices)  # A_col is an AbstractVector with contiguous indices 1:length(colindices)\n        B_col = view(vars.B, colindices)  # B_col is an AbstractVector with contiguous indices 1:length(colindices)\n        \n        # do something that needs a vector of cells for a whole column\n    end\n\n    return nothing\nend","category":"page"},{"location":"Reaction API/#Optimising-loops-over-cells-using-explicit-SIMD-instructions","page":"Reaction API","title":"Optimising loops over cells using explicit SIMD instructions","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"Reactions with simple loops over cellindices that implement time-consuming per-cell calculations  may be optimised by using explicit SIMD instructions.","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"SIMDutils.SIMDIter","category":"page"},{"location":"Reaction API/#PALEOboxes.SIMDutils.SIMDIter","page":"Reaction API","title":"PALEOboxes.SIMDutils.SIMDIter","text":"SIMDIter(baseiter, Val{N})\nSIMDIter(baseiter, ::Type{SIMD.Vec{N, U}})\nSIMDIter(baseiter, ::Val{1}) # scalar fallback\nSIMDIter(baseiter, ::Type{U}) where {U <: Real} # scalar fallback\n\nIterator that takes up to N SIMD elements at a time from baseiter (which should represent indices into a Vector). See Julia package SIMD.jl\n\nIf baseiter contained 1 or more but less then N elements, then indices is filled with repeats of the last available element.\n\nReturns Tuple of indices (length N).\n\nExamples\n\nv_a = [1.0, 2.0, 3.0, 4.0, 5.0]\nv_b = similar(v_a)\n\niter = eachindex(v_a) # iter should represent indices into a Vector\n\n# simplest version - Float64 x 4, ie type of v_a x 4\n\nfor i in SIMDIter(iter, Val(4))\n    x = v_a[i]  # x is a packed SIMD vector\n    v_b[i] = x\nend\n\n\n# with type conversion - Float32 x 8, ie explicitly change Type of SIMD vector\n\nST = SIMD.Vec{8, Float32}}    \nfor i in SIMDIter(iter, ST)\n    #   v = vec[i]  <--> vgatherind(ST, vec, i)\n    #   vec[i] = v  <--> vscatterind!(v, vec, i)\n    #   vec[i] += v <--> vaddind!(v, vec, i) \n\n    x = vgatherind(ST, v_a, i)  # x is a packed SIMD vector with type conversion to Float32\n    vscatterind!(x, v_b, i)\nend\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#Adding-ReactionMethods","page":"Reaction API","title":"Adding ReactionMethods","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"ReactionMethod\nadd_method_setup!\nadd_method_initialize!\nadd_method_do!","category":"page"},{"location":"Reaction API/#PALEOboxes.ReactionMethod","page":"Reaction API","title":"PALEOboxes.ReactionMethod","text":"ReactionMethod(\n    methodfn::Function,\n    reaction::AbstractReaction,\n    name::String,\n    varlists::Tuple{Vararg{AbstractVarList}},\n    p, \n    operatorID::Vector{Int64}, \n    domain::AbstractDomain; \n    preparefn = (m, vardata) -> vardata\n) -> m::ReactionMethod\n\nDefines a callback function methodfn with Variables varlists, to be called from the Model framework either during setup or as part of the main loop.\n\nFields\n\nmethodfn: callback from Model framework\nreaction: the Reaction that created this ReactionMethod\nname: a descriptive name, eg generated from the name of methodfn\nvarlists: Tuple of VarLists, each representing a list of VariableReactions.     Corresponding Variable accessors vardata (views on Arrays) will be provided to the methodfn callback.     NB: not concretely typed to reduce compile time, as not performance-critical\np: optional context field (of arbitrary type) to store data needed by methodfn.\noperatorID\ndomain\npreparefn: preparefn(m::ReactionMethod, vardata::Tuple) -> modified_vardata::Tuple      optionally modify vardata to eg add buffers. NB: not concretely typed as not performance-critical\n\nmethodfn\n\nThe methodfn callback is:\n\nmethodfn(m::ReactionMethod, pars, vardata::Tuple, cellrange::AbstractCellRange, modelctxt)\n\nor (if Parameters are not required):\n\nmethodfn(m::ReactionMethod, vardata::Tuple, cellrange::AbstractCellRange, modelctxt)\n\nWith arguments:\n\nm::ReactionMethod: context is available as m.reaction::AbstractReaction (the Reaction that defined the ReactionMethod), and m.p (an arbitrary extra context field supplied when ReactionMethod created).\npars: a struct with Parameters as fields (current just the ParametersTuple defined as reaction.pars)\nvardata: A Tuple of collections of views on Domain data arrays corresponding to VariableReactions defined by varlists\ncellrange::AbstractCellRange: range of cells to calculate.\nmodelctxt:\nfor a setup method, :setup, :initial_value or :norm_value defining the type of setup requested\nfor a main loop method deltat providing timestep information eg for rate throttling.\n\npreparefn\n\nAn optional preparefn callback can be supplied eg to allocate buffers that require knowledge of the data types of vardata or to cache expensive calculations:\n\npreparefn(m::ReactionMethod, vardata::Tuple) -> modified_vardata::Tuple\n\nThis is called after model arrays are allocated, and prior to setup.\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.add_method_setup!","page":"Reaction API","title":"PALEOboxes.add_method_setup!","text":"add_method_setup!(reaction::AbstractReaction, method::AbstractReactionMethod)\nadd_method_setup!(reaction::AbstractReaction, methodfn::Function, vars::Tuple{Vararg{AbstractVarList}}; kwargs...) -> ReactionMethod\n\nAdd or create-and-add a setup method (called before main loop) eg to set persistent data or initialize state variables. methodfn, vars, kwargs are passed to ReactionMethod.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.add_method_initialize!","page":"Reaction API","title":"PALEOboxes.add_method_initialize!","text":"add_method_initialize!(reaction::AbstractReaction, method::AbstractReactionMethod)\nadd_method_initialize!(reaction::AbstractReaction, methodfn::Function, vars::Tuple{Vararg{AbstractVarList}}; kwargs...) -> ReactionMethod\n\nAdd or create-and-add an initialize method (called at start of each main loop iteration)  eg to zero out accumulator Variables. methodfn, vars, kwargs are passed to ReactionMethod.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.add_method_do!","page":"Reaction API","title":"PALEOboxes.add_method_do!","text":"add_method_do!(reaction::AbstractReaction, method::AbstractReactionMethod)\nadd_method_do!(reaction::AbstractReaction, methodfn::Function, vars::Tuple{Vararg{AbstractVarList}}; kwargs...) -> ReactionMethod\n\nAdd or create and add a main loop method. methodfn, vars, kwargs are passed to ReactionMethod.\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Predefined-ReactionMethods","page":"Reaction API","title":"Predefined ReactionMethods","text":"","category":"section"},{"location":"Reaction API/#Setup-and-initialization-of-Variables","page":"Reaction API","title":"Setup and initialization of Variables","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"add_method_setup_initialvalue_vars_default!\nadd_method_initialize_zero_vars_default!","category":"page"},{"location":"Reaction API/#PALEOboxes.add_method_setup_initialvalue_vars_default!","page":"Reaction API","title":"PALEOboxes.add_method_setup_initialvalue_vars_default!","text":"add_method_setup_initialvalue_vars_default!(react::AbstractReaction, variables [; kwargs...])\n\nCreate and add a default method to initialize Variables matching filterfn (defaults to state Variables) at beginning of integration.\n\nSetup callbacks used\n\nState Variables and similar (:vfunction != VF_Undefined) are initialized in a setup callback with  attribute_name in (:initial_value, :norm_value), with values from those Variable attributes.\nIf force_state_norm_value=false, other Variables (with :vfunction == VF_Undefined) are initialized in a setup callback with  attribute_name=:setup, with values from the :initial_value Variable attribute. NB: filterfn must be set to include these Variables.\nIf force_initial_norm_value=true, all Variables (including those with :vfunction == VF_Undefined) are initialised as state Variables\n\nKeywords\n\nfilterfn: set to f(var)::Bool to override the default selection for state variables only (Variables with :vfunction in (VF_StateExplicit, VF_State, VF_Total, VF_Constraint))\nforce_initial_norm_value=false: true to always use :initial_value, :norm_value, even for variables with :vfunction=VF_Undefined\ntransfer_attribute_vars=[]: Set to a list of the same length as variables to initialise variables from attributes of transfer_attribute_vars.\nsetup_callback=(method, attribute_name, var, vardata) -> nothing: Set to a function that is called  after each Variable initialisation eg to store norm values.\nconvertvars=[]\nconvertfn = (convertvars_tuple, i) -> 1.0\nconvertinfo = \"\"\n\nIncluding volume etc conversion\n\nSet convertvars to a Vector of Variables (eg for cell volume) and supply convertfn and convertinfo  to initialize to :initial_value*convertfn(convertvars_tuple, i) where the argument of convertfn is the Tuple generated by VarList_tuple(convertvars).\n\nExample: To interpret :initial_value as a concentration-like quantity:\n\nconvertvars = [volume], \nconvertfn = ((volume, ), i) -> volume[i], \nconvertinfo = \" * volume\"\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.add_method_initialize_zero_vars_default!","page":"Reaction API","title":"PALEOboxes.add_method_initialize_zero_vars_default!","text":"add_method_initialize_zero_vars_default!(react::AbstractReaction, variables=PB.get_variables(react))\n\nCreate and add a default method to initialize Variables to zero at beginning of each timestep. Defaults to adding all Variables from react with :initialize_to_zero attribute true.\n\nNB: TODO variables are converted to VarDep (no dependency checking or sorting needed, could define a VarInit or similar?)\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Adding-totals-for-Variables","page":"Reaction API","title":"Adding totals for Variables","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"add_method_do_totals_default!","category":"page"},{"location":"Reaction API/#PALEOboxes.add_method_do_totals_default!","page":"Reaction API","title":"PALEOboxes.add_method_do_totals_default!","text":"add_method_do_totals_default!(react::AbstractReaction; total_candidates=PB.get_variables(react)\n    [filterfn] [, methodname] [, total_localnames] [, operatorID])\n\nCreate and add a method to add total variables (Scalar Properties), for Variables in total_candidates that match filterfn (defaults to those that are Array Variables and have attribute `:calc_total == true).\n\nNB: total Variables will require initialization to zero using add_method_initialize_zero_vars_default!\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Chemical-reactions","page":"Reaction API","title":"Chemical reactions","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"RateStoich\ncreate_ratestoich_method","category":"page"},{"location":"Reaction API/#PALEOboxes.RateStoich","page":"Reaction API","title":"PALEOboxes.RateStoich","text":"RateStoich(ratevartemplate, stoich_statevarname; deltavarname_eta=nothing,\n           sms_prefix=\"\", sms_suffix=\"_sms\") -> RateStoich\n\nCalculate fluxes for a biogeochemical reaction given rate, stoichiometry, and optionally isotope eta.\n\nAdd to a Reaction using create_ratestoich_method and add_method_do!.  \n\nA Property Variable should be set to provide the reaction rate (often this is implemented by another method of the same Reaction).\n\nThis method will then link to that (using the local and link names supplied by ratevartemplate) and calculate the appropriate product rates, omitting products that are not present (VariableReaction not linked) in the Model configuration.\n\nArguments:\n\nratevartemplate::Union{VarPropT, VarDepT}: used to define the rate variable local and link names.\nstoich_statevarname: collection of Tuple(stoichiometry, name) eg ((-2.0, \"O2\"), (-1.0,\"H2S::Isotope\"), (1.0, \"SO4::Isotope\"))\ndeltavarname_eta: optional tuple of variable delta + eta (\"SO4_delta\", -30.0) or (\"SO4_delta\", rj.pars.delta). If a Parameter is supplied, this is read in do_react_ratestoich to allow modification.\n\nExamples:\n\nCreate a RateStoich representing the reaction   2 O2 + H2S -> H2SO4\n\njulia> myratevar = PALEOboxes.VarProp(\"myrate\", \"mol yr-1\", \"a rate\");\n\njulia> rs = PALEOboxes.RateStoich(myratevar, ((-2.0, \"O2\"), (-1.0,\"H2S\"), (1.0, \"SO4\")));\n\njulia> rs.stoich_statevarname\n((-2.0, \"O2\"), (-1.0, \"H2S\"), (1.0, \"SO4\"))\n\n\n\n\n\n","category":"type"},{"location":"Reaction API/#PALEOboxes.create_ratestoich_method","page":"Reaction API","title":"PALEOboxes.create_ratestoich_method","text":"create_ratestoich_method(reaction::AbstractReaction, ratestoich::RateStoich; isotope_data=ScalarData)\n    -> ReactionMethod\n\nCreate method (see RateStoich).\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#Internal-details-of-Variable-arrays-accessor-generation","page":"Reaction API","title":"Internal details of Variable arrays accessor generation","text":"","category":"section"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"VariableReactions in the AbstractVarLists for a ReactionMethod are processed by create_accessor to supply views on arrays as corresponding arguments to the ReactionMethod function.","category":"page"},{"location":"Reaction API/","page":"Reaction API","title":"Reaction API","text":"create_accessor\ncreate_accessors","category":"page"},{"location":"Reaction API/#PALEOboxes.create_accessor","page":"Reaction API","title":"PALEOboxes.create_accessor","text":" create_accessor(var::VariableReaction, modeldata, arrays_idx, components, [,forceview=false])\n    -> accessor or (accessor, subdomain_indices)\n\nCreates a view on a (single) VariableDomain data array linked by var::VariableReaction. Called by an AbstractVarList create_accessors implementation to generate a collection of views for multiple VariableReactions.\n\nReturns:\n\nif var is linked, an accessor or Tuple (accessor, subdomain_indices) that provides a view on variable data.\nif var is not linked, nothing if var is optional, or errors and doesn't return if var is non-optional.\n\nMapping of indices for Subdomains <–> Domains:\n\nif no Subdomain, returns unmodified indices (if forceview=false),    or an equivalent view (if forceview=true, this is to help type stability) \nif Variable is a Domain interior and Subdomain is a Domain boundary,   accessor is a view with a subset of Domain indices.\nif Variable is a Domain boundary and Subdomain is the Domain interior,   returns a Tuple with subdomain_indices,  length(Subdomain size), with missing for interior points.\n\nMapping of multi-component (Isotope) Variables:\n\nIf components=false:\nmap multi-component Variable to accessor::IsotopeArray\nreturn a single-component Variable as a accessor::AbstractArray. \nIf components=true:\nvariable data as a accessor::Vector{Array}, length=number of components\n\n\n\n\n\n","category":"function"},{"location":"Reaction API/#PALEOboxes.create_accessors","page":"Reaction API","title":"PALEOboxes.create_accessors","text":"create_accessors(varlist::AbstractVarList, modeldata::AbstractModelData, arrays_idx::Int) -> vardata\n\nReturn a collection vardata of views on Domain data arrays for VariableReactions in varlist. Collection and view are determined by varlist Type.\n\n\n\n\n\n","category":"function"},{"location":"#PALEOboxes.jl","page":"Home","title":"PALEOboxes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PALEOboxes.jl provides the model coupler for the PALEO model framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PALEO provides a toolkit for constructing biogeochemical reaction-transport models of Earth system components (eg atmosphere, ocean, sediment) as a well as coupled Earth system configurations.  Model structure as well as parameters are described by a configuration file, making it straightforward to add and remove biogeochemical tracers and their interactions, change the representation of eg ocean circulation, and couple components together.  ","category":"page"}]
}
